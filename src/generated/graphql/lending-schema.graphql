type ActiveOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  offer: Offer!
  offerId: String!
  readOn: DateTime
  user: User!
}

interface Activity implements Event & Node {
  id: String!
  timestamp: DateTime!
  txHash: Hash!
}

scalar Address

type Asset implements Node {
  accessTypeName: String!
  cacheUrl: String
  contentTypeMime: String!
  data: String!
  id: String!
}

type Auction implements Node {
  duration: BigInt
  endTime: DateTime
  highestBid: Bid
  id: String!
  loan: MultiSourceLoan!
  minBid: BigInt!
  originator: Address
  settler: Address
  startTime: DateTime
  status: String!
  triggerFee: BigInt
}

type AuctionBidConfirmationNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  bid: Bid!
  bidId: Int!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type AuctionConnection {
  edges: [AuctionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AuctionEdge {
  cursor: String!
  node: Auction!
}

type AuctionEndedNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

enum AuctionSortField {
  END_TIME
}

input AuctionSortInput {
  field: AuctionSortField!
  order: Ordering!
}

type AuctionStartedNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

enum AuctionStatus {
  ENDED
  LIVE
  PAST
  UPCOMING
}

type AuctionWonNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

input BNPLOrderInput {
  amounts: [BigInt!]!
  contractAddress: Address!
  emitSignature: Signature = null
  extraSeaportData: Hex = null
  loanDuration: BigInt!
  offerIds: [String!]!
  signature: Signature = null
  tokenId: BigInt!
}

type Bid implements Node {
  amount: BigInt!
  auction: Auction!
  auctionId: String!
  bidder: Address!
  id: String!
  indexInBlock: Int!
  timestamp: DateTime!
  txHash: Hash!
}

type BidConnection {
  edges: [BidEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type BidEdge {
  cursor: String!
  node: Bid!
}

enum BidSortField {
  BID
  HIGHEST_BID
}

input BidSortInput {
  field: BidSortField!
  order: Ordering!
}

scalar BigInt

type BigIntCurrencyAmount {
  amount: BigInt!
  currency: Currency!
}

input BigIntInterval {
  max: BigInt = null
  min: BigInt = null
}

type BuyNowPayLaterOrder implements Event & Node & Order {
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  emitCalldata: Hex!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nft: NFT!
  nftId: Int!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

union BuyNowPayLaterOrderSignatureRequestExtraSeaportData = BuyNowPayLaterOrder | ExtraSeaportData | SignatureRequest

"""An NFT collection."""
type Collection implements Node {
  bannerImage: Asset
  collectionUrl: String
  contractData: ContractData!
  description: String
  discordUrl: String
  externalUrl: String
  id: String!
  image: Asset
  imageId: String
  maxNetPrincipalOffer(currencyAddress: Address!): CollectionOffer
  name: String
  nftsCount: Int
  royalties: [Royalty!]!
  slug: String!
  statistics: CollectionStatistics!
  supply: BigInt
  twitterUsername: String
  verified: Boolean!
  wrappedCollection: Collection
  wrappedCollectionId: Int
  wrapperCollections: [Collection!]!
}

type CollectionConnection {
  edges: [CollectionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CollectionEdge {
  cursor: String!
  node: Collection!
}

type CollectionEventsCountByDayAndCurrency {
  auctions: BigInt!
  buyouts: BigInt!
  defaults: BigInt!
  foreclosings: BigInt!
  originations: BigInt!
  refinancings: BigInt!
  renegotiations: BigInt!
  repayments: BigInt!
  topUps: BigInt!
}

type CollectionLoansData {
  maxAprBps: Float!
  maxPrincipalAmount: BigInt!
  maxRemainingTime: BigInt!
  minAprBps: Float!
  minPrincipalAmount: BigInt!
  minRemainingTime: BigInt!
}

type CollectionOffer implements Event & Node & Offer {
  aprBps: BigInt!
  availablePrincipalAmount: BigInt!
  borrowerAddress: Address
  capacity: BigInt!
  collateralAddress: Address
  collection: Collection!
  collectionId: Int
  consumedCapacity: BigInt!
  contractAddress: Address!
  createdDate: DateTime
  currency: Currency!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  hidden: Boolean
  id: String!
  lenderAddress: Address
  lenderAvailableBalance: BigInt
  maxPrincipal: BigInt!
  maxSeniorRepayment: BigInt!

  """Deprecated field: use maxSeniorRepayment instead."""
  maxTrancheFloor: BigInt! @deprecated(reason: "Use maxSeniorRepayment instead.")
  netPrincipal: BigInt!
  nftId: Int
  offerHash: Hash
  offerId: BigInt!
  principalAddress: Address!
  principalAmount: BigInt!
  repayment: BigInt!
  requiresLiquidation: Boolean
  signature: Signature
  signerAddress: Address
  statistics: CollectionOfferStatistics!
  status: String!
  timestamp: DateTime!
  validators: [OfferValidator!]!
}

input CollectionOfferInput {
  aprBps: BigInt!
  borrowerAddress: Address!
  capacity: BigInt!
  collectionId: Int!
  contractAddress: Address!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  lenderAddress: Address!
  maxSeniorRepayment: BigInt = null
  maxTrancheFloor: BigInt = null
  offerValidators: [OfferValidatorInput!]!
  principalAddress: Address!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signerAddress: Address = null
}

type CollectionOfferStatistics {
  acceptedLoans: Int!
  consumedCapacity: BigInt!
}

type CollectionOrder implements Event & Node & Order {
  collection: Collection!
  collectionId: Int!
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  executions: Int!
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  maxExecutions: Int!
  netAmount: BigInt!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

input CollectionOrderInput {
  amount: BigInt!
  collectionId: Int!
  currencyAddress: Address!
  expirationTime: BigInt!
  fees: [OrderFee!] = null
  isAsk: Boolean = null
  maxExecutions: BigInt = null
  signature: Signature = null
  startTime: BigInt!
  taker: Address = null
}

union CollectionOrderSignatureRequest = CollectionOrder | SignatureRequest

input CollectionSignedOfferInput {
  aprBps: BigInt!
  borrowerAddress: Address!
  capacity: BigInt!
  collectionId: Int!
  contractAddress: Address!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  lenderAddress: Address!
  maxSeniorRepayment: BigInt = null
  maxTrancheFloor: BigInt = null
  offerHash: Hash!
  offerId: BigInt!
  offerValidators: [OfferValidatorInput!]!
  principalAddress: Address!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signature: Signature!
  signerAddress: Address = null
}

enum CollectionSortField {
  FLOOR_PRICE
  FLOOR_PRICE_7D_CHANGE
  FLOOR_PRICE_30D_CHANGE
  LENDERS_OUTSTANDING_PRINCIPAL
  LISTING_COUNT
  LOAN_COUNT
  OFFER_COUNT
  OUTSTANDING_PRINCIPAL
  OWNERS_TOTAL_VALUE
  SALE_LISTING_COUNT
  TOTAL_LOAN_VOLUME
  TOTAL_OUTSTANDING_PRINCIPAL
  TOTAL_VOLUME
  TOTAL_VOLUME_7D
  TOTAL_VOLUME_30D
  TRENDING_VOLUME
}

input CollectionSortInput {
  field: CollectionSortField!
  lenders: [Address!] = null
  marketplaces: [MarketPlaceType!] = null
  order: Ordering!
  owners: [Address!] = null
  principalAddress: Address = null
}

type CollectionStatistics {
  bestOffer: CurrencyAmount @deprecated(reason: "Use highest_bid instead.")
  floorPrice: CurrencyAmount
  floorPrice7d: Float
  floorPrice30d: Float
  floorPriceHistory(fromDate: DateTime!, toDate: DateTime!): [FloatStatHistory!]!
  highestBid: Order
  maxAskPrice(currencyAddresses: [Address!] = null): BigIntCurrencyAmount
  minAskPrice(currencyAddresses: [Address!] = null): BigIntCurrencyAmount
  nftsCount: Float
  numberOfListings: Int!
  numberOfNftsOwned(walletAddresses: [Address!] = null): Int!

  """Deprecated field. Use number_of_offers_for_currencies instead."""
  numberOfOffers(currencyAddress: Address!): Float! @deprecated(reason: "Use number_of_offers_for_currencies instead.")
  numberOfOffersForCurrencies(currencyAddresses: [Address!]!): Int!
  numberOfPricedNfts(marketplaces: [MarketPlaceType!] = null): Int!
  outstandingLoanCount: Int!
  outstandingNftsCount: BigInt!
  outstandingPrincipal(currencyAddress: Address!): BigInt!
  percentageInOutstandingLoans: Float!
  repaymentRate: Float!
  topBidHistory(fromDate: DateTime!, toDate: DateTime!): [FloatStatHistory!]!
  totalLoanVolume(currencyAddress: Address!): BigInt!
  totalLoanVolume1d(currencyAddress: Address!): BigInt!
  totalLoanVolume1m(currencyAddress: Address!): BigInt!
  totalLoanVolume1w(currencyAddress: Address!): BigInt!
  totalLoanVolume1y(currencyAddress: Address!): BigInt!
  totalLoanVolume2m(currencyAddress: Address!): BigInt!
  totalLoanVolume3m(currencyAddress: Address!): BigInt!
  totalLoanVolume4m(currencyAddress: Address!): BigInt!
  totalOutstandingPrincipal: BigInt!
  totalVolume: Float
  totalVolume1d: Float
  totalVolume1m: Float
  totalVolume1w: Float
  totalVolume1y: Float
  totalVolume2m: Float
  totalVolume3m: Float
  totalVolume4m: Float
}

type ContractData implements Node {
  blockchain: String!
  contractAddress: Address!
  createdDate: DateTime!
  creatorAddress: Address
  id: String!
  standard: String!
}

type Currency implements Node {
  address: Address!
  currentEthRate: Float
  currentUsdcPrice: Float
  decimals: Int!
  id: String!
  rateAtTime(timestamp: DateTime!): Float
  symbol: String!
  usdcPriceAtTime(timestamp: DateTime!): Float
}

type CurrencyAmount {
  amount: Float!
  currency: Currency!
}

type CurrencyConnection {
  edges: [CurrencyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CurrencyEdge {
  cursor: String!
  node: Currency!
}

"""Date with time (isoformat)"""
scalar DateTime

type Delegation implements Node {
  contractAddress: String!
  delegateTo: Address!
  id: String!
  nft: NFT!
  timestamp: DateTime!
}

type DelegationConnection {
  edges: [DelegationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DelegationEdge {
  cursor: String!
  node: Delegation!
}

type ERC4626Deposit implements Node & PoolActivity {
  assets: BigInt!
  caller: Address!
  id: String!
  indexInBlock: Int!
  owner: Address!
  pool: Pool!
  poolAddress: Address!
  shares: BigInt!
  timestamp: DateTime!
  txHash: Hash!
}

type ERC4626Withdraw implements Node & PoolActivity {
  assets: BigInt!
  caller: Address!
  id: String!
  indexInBlock: Int!
  owner: Address!
  pool: Pool!
  poolAddress: Address!
  receiver: Address!
  shares: BigInt!
  timestamp: DateTime!
  txHash: Hash!
}

interface Event implements Node {
  id: String!
  timestamp: DateTime!
}

type EventConnection {
  edges: [EventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EventEdge {
  cursor: String!
  node: Event!
}

enum EventType {
  BUY_OFFER
  CLAIM
  COLLECTION_BUY_OFFER
  LOAN_AUCTIONED
  LOAN_BOUGHT_OUT
  LOAN_COLLECTION_OFFER
  LOAN_DEFAULTED
  LOAN_EXTENDED
  LOAN_FORECLOSED
  LOAN_INITIATED
  LOAN_LISTING
  LOAN_NFT_OFFER
  LOAN_PARTIAL_REFINANCED
  LOAN_PARTIAL_REFINANCED_TRANSFER
  LOAN_REFINANCED
  LOAN_REFINANCED_TRANSFER
  LOAN_RENEGOTIATED
  LOAN_RENEGOTIATED_PAYMENT
  LOAN_RENEGOTIATION_OFFER
  LOAN_REPAID
  LOAN_SENT_TO_AUCTION
  LOAN_TOPED_UP
  LOAN_TOP_UP_OFFER
  LOAN_TRANCHE_REFINANCED
  LOAN_TRANCHE_REFINANCED_TRANSFER
  SALE
  SALE_LISTING
  TRANSFER
}

type ExtraSeaportData {
  extraData: Hex!
}

type FloatStatHistory {
  timestamp: DateTime!
  value: Float!
}

input ForWalletsInput {
  borrowersWallets: [Address!] = null
  lendersWallets: [Address!] = null
  ownersWallets: [Address!] = null
}

interface GlobalSearchResult {
  id: String!
}

type GlobalSearchResultAccount implements GlobalSearchResult {
  id: String!
  user: User!
}

type GlobalSearchResultCollection implements GlobalSearchResult {
  collection: Collection!
  id: String!
}

type GlobalSearchResultNFT implements GlobalSearchResult {
  id: String!
  nft: NFT!
}

scalar Hash

scalar Hex

input Interval {
  max: Float = null
  min: Float = null
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf).
"""
scalar JSON

type LinkedWallets implements Node {
  id: String!
  pending: Boolean!
  shouldAccept: Boolean!
  walletAddress: String!
}

type Listing implements Node {
  createdDate: DateTime!
  desiredDuration: Int
  desiredPrincipalAddress: Address
  expirationDate: DateTime!
  id: String!
  marketplaceName: MarketplaceEnum!
  nft: NFT!
  user: User!
}

type ListingConnection {
  edges: [ListingEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ListingEdge {
  cursor: String!
  node: Listing!
}

interface Loan implements Node {
  activities: [LoanActivity!]!
  address: Address!
  borrowerAddress: Address!
  contractStartTime: DateTime!
  currency: Currency!
  duration: BigInt!
  id: String!
  indexInBlock: Int!
  loanId: Int!

  """Deprecated field. Use offerIds to return loan offer ids instead."""
  offer: Offer! @deprecated(reason: "Use offerIds to return loan offer ids instead.")
  offerIds: [String!]!
  principalAddress: Address!
  protocolFee: BigInt!
  repaidActivity: LoanRepaid
  repaymentTime: DateTime
  startTime: DateTime!
  status: String!
  timestamp: DateTime!
  txHash: Hash!
}

type LoanActivitiesStatisticsByMonth {
  count: [Int!]!
  outstanding: [BigInt!]!
}

interface LoanActivity implements Event & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanActivityConnection {
  edges: [LoanActivityEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LoanActivityEdge {
  cursor: String!
  node: LoanActivity!
}

enum LoanActivitySortField {
  TIMESTAMP
}

input LoanActivitySortInput {
  field: LoanActivitySortField!
  order: Ordering!
}

enum LoanActivityType {
  LOAN_AUCTIONED
  LOAN_EXTENDED
  LOAN_FORECLOSED
  LOAN_INITIATED
  LOAN_REFINANCED
  LOAN_REFINANCED_FROM_OFFERS
  LOAN_REPAID
  LOAN_SENT_TO_AUCTION
}

type LoanAuctioned implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  loanPayments: [LoanPayment!]!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  totalAuctioned: BigInt!
  txHash: Hash!
  withBuyout: Boolean!
}

type LoanAuctionedNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type LoanDefaultReminderNotification implements Node & Notification {
  createdOn: DateTime!
  defaultsInHours: Int!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type LoanDefaulted implements Event & LoanEvent & Node {
  eventType: String!
  id: String!
  loan: Loan!
  loanId: String!
  timestamp: DateTime!
}

type LoanDefaultedNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

interface LoanEvent implements Event & Node {
  eventType: String!
  id: String!
  loan: Loan!
  loanId: String!
  timestamp: DateTime!
}

type LoanEventConnection {
  edges: [LoanEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LoanEventEdge {
  cursor: String!
  node: LoanEvent!
}

enum LoanEventSortField {
  TIMESTAMP
}

input LoanEventSortInput {
  field: LoanEventSortField!
  order: Ordering!
}

enum LoanEventType {
  LOAN_AUCTIONED
  LOAN_BOUGHT_OUT
  LOAN_DEFAULTED
  LOAN_EXTENDED
  LOAN_FORECLOSED
  LOAN_INITIATED
  LOAN_REFINANCED
  LOAN_RENEGOTIATED
  LOAN_REPAID
  LOAN_SENT_TO_AUCTION
  LOAN_TOPED_UP
}

type LoanExtended implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanExtendedNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  newHistory: MultiSourceLoanHistory!
  newHistoryId: String!
  notificationType: String!
  previousHistory: MultiSourceLoanHistory!
  previousHistoryId: String!
  readOn: DateTime
  user: User!
}

type LoanForeclosed implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanInitiated implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

"""Loan listing created event"""
type LoanListingEvent implements Event & Node {
  createdDate: DateTime!
  desiredDuration: Int
  desiredPrincipalAddress: Address
  expirationDate: DateTime!
  id: String!
  marketplaceName: MarketplaceEnum!
  nft: NFT!
  timestamp: DateTime!
  user: User!
}

type LoanPayment implements Node {
  accruedInterest: BigInt!
  activityId: String!
  destination: Address!
  id: String!
  pendingInterest: BigInt!
  principalAddress: Address!
  principalAmount: BigInt!
  protocolFee: BigInt!
  source: Address!
}

type LoanRefinanced implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  addedNewTranche: Boolean!
  eventType: String!
  id: String!
  indexInBlock: Int!
  isRenegotiation: Boolean!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanRefinancedFromOffers implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanRefinancedNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  newHistory: MultiSourceLoanHistory!
  newHistoryId: String!
  notificationType: String!
  previousHistory: MultiSourceLoanHistory!
  previousHistoryId: String!
  readOn: DateTime
  user: User!
}

type LoanRepaid implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  totalInterest: BigInt!
  txHash: Hash!
}

type LoanRepaidNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

enum LoanRequestType {
  NFT_LISTED_FOR_SALE
  RENEGOTIATION_REQUEST
  TOP_UP_REQUEST
}

type LoanSentToAuction implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  liquidatorAddress: String!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

enum LoanSortField {
  APR_BPS
  DURATION
  EFFECTIVE_APR_BPS
  END_DATE
  EXPECTED_INTEREST
  EXPIRATION_DATE
  ORIGINATION_FEE
  PAID_INTEREST
  PRINCIPAL_AMOUNT
  RENEGOTIATION_REQUESTED
  START_TIME
  TOTAL_INTEREST
}

input LoanSortInput {
  field: LoanSortField!
  order: Ordering!
}

enum LoanStatusType {
  LOAN_AUCTIONED
  LOAN_AUCTIONED_WITH_BUYOUT
  LOAN_DEFAULTED
  LOAN_FORECLOSED
  LOAN_INITIATED
  LOAN_REPAID
  LOAN_SENT_TO_AUCTION
}

type LoansData {
  maxAprBps: Float!
  maxPrincipalAmount: BigInt!
  maxRemainingTime: BigInt!
  minAprBps: Float!
  minPrincipalAmount: BigInt!
  minRemainingTime: BigInt!
}

"""
This is the definition of a lost source. Lost sources are the lender/s that have lost a loan because of renegotiation or refinance. 
"""
type LostSource implements Node {
  accruedInterest: BigInt!
  activity: LoanActivity!
  activityId: String!
  aprBps: BigInt!
  duration: BigInt!
  earnedInterest: BigInt!
  endDate: DateTime!
  expectedInterestLeft: BigInt!
  id: String!
  lenderAddress: String!
  lenderEaprBps: BigInt!
  loan: MultiSourceLoan!
  originationFee: BigInt!
  principalAmount: BigInt!
  profit: BigInt!
  repaidInterest: BigInt!
  startTime: DateTime!
}

type LostSourceNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  lostSource: LostSource!
  lostSourceId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

enum MarketPlaceType {
  BLUR
  CRYPTOPUNKS
  FOUNDATION
  LARVA_LABS
  LOOKS_RARE
  NATIVE
  NFTX
  OPEN_SEA
  X2Y2
}

enum MarketplaceEnum {
  GONDI
  NFTFI
}

"""
This is the definition of a loan. In sources you can find the tranches of the loan.Take into account that the loan fields can change if renegotiation or refinance happens.You can use listLoanEvents to get the history of the loan.
"""
type MultiSourceLoan implements Loan & Node {
  activities: [LoanActivity!]!
  address: Address!
  auction: Auction
  blendedAprBps: Float!
  borrowerAddress: Address!
  contractStartTime: DateTime!
  currency: Currency!
  duration: BigInt!
  durationFromRenegotiationOrStart: BigInt!
  endDate: DateTime!
  id: String!
  indexInBlock: Int!
  isEndLockedUp: Boolean!
  lastOriginationFee: BigInt!
  lastRenegotiationDate: DateTime
  loanId: Int!
  nft: NFT!

  """Deprecated field. Use offerIds to return loan offer ids instead."""
  offer: Offer! @deprecated(reason: "Use offerIds to return loan offer ids instead.")
  offerIds: [String!]!
  principalAddress: Address!
  principalAmount: BigInt!
  protocolFee: BigInt!
  renegotiationCount: Int!
  renegotiationRequest: RenegotiationRequest
  repaidActivity: LoanRepaid
  repayment: BigInt!
  repaymentTime: DateTime
  sources: [Source!]!
  startLockDueDate: DateTime
  startTime: DateTime!
  status: String!
  timestamp: DateTime!
  topUpRequest: TopUpRequest
  totalOriginationFee: BigInt!
  txHash: Hash!
}

type MultiSourceLoanConnection {
  edges: [MultiSourceLoanEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MultiSourceLoanEdge {
  cursor: String!
  node: MultiSourceLoan!
}

"""A snapshot in time of a loan."""
type MultiSourceLoanHistory implements Node {
  activity: LoanActivity!
  activityId: String!
  borrowerAddress: String!
  currency: Currency!
  duration: BigInt!
  id: String!
  loanId: Int!
  nft: NFT!
  offerIds: [String!]!
  principalAddress: Address!
  principalAmount: BigInt!
  sources: [SourceHistory!]!
  startTime: DateTime!
}

type Mutation {
  """
  Lists all NFTs from a user to start receiving loan offers. Can be filtered to only match certain criteria.
  """
  addListingsOfNftsFromUser(desiredDuration: Int = null, desiredPrincipalAddress: Address = null, excludeCollections: [String!] = null, onlyCollections: [String!] = null, searchTerm: String = null): Void

  """Adds or updates a loan listing to start receiving loan offers."""
  addOrUpdateListing(desiredDuration: Int = null, desiredPrincipalAddress: Address = null, nftId: Int!): Listing!

  """
  Adds or updates a loan renegotiation request.A renegotiation request is only a suggestion for potential lenders to show your intentions and the terms you want.
  """
  addOrUpdateRenegotiationRequest(desiredAprBps: BigInt = null, desiredDuration: BigInt = null, desiredPrincipalAmount: BigInt = null, loanId: String!): RenegotiationRequest!

  """
  Adds or updates a loan top-up request.A top-up request is only a suggestion for potential lenders to show your intentions and the terms you want.
  """
  addOrUpdateTopUpRequest(desiredAprBps: BigInt = null, desiredTopUp: BigInt = null, loanId: String!): TopUpRequest!

  """
  This is the first step of the collection loan offer flow. This step populates some fields of the offer. You then have to sign the offer and save it using the method save_signed_collection_offer. Refer to gondi-js examples for more details.
  """
  generateCollectionOfferToBeSigned(offerInput: CollectionOfferInput!): CollectionOffer!

  """
  This is the first step of the renegotiation loan offer flow. This step populates some fields of the offer. You then have to sign the offer and save it using the method save_renegotiation_signed_offer. Refer to gondi-js examples for more details.
  """
  generateRenegotiationOfferToBeSigned(renegotiationInput: RenegotiationOfferInput!): Renegotiation!

  """
  This is the first step of the single NFT loan offer flow. This step populates some fields of the offer. You then have to sign the offer and save it using the method save_signed_single_nft_offer. Refer to gondi-js examples for more details.
  """
  generateSingleNftOfferToBeSigned(offerInput: SingleNFTOfferInput!): SingleNFTOffer!

  """Hides all loan offers from a user for a given contract address. """
  hideAllOffers(contractAddress: Address!, minOfferId: String!): [Offer!]!

  """Hides a loan offer."""
  hideOffer(contractAddress: Address!, offerId: String!): Offer!

  """Hides a trade order."""
  hideOrder(orderId: Int!): Order!

  """Hides a loan renegotiation offer. """
  hideRenegotiation(contractAddress: Address = "0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9", renegotiationId: String!): Renegotiation!
  markNotificationIdsAsRead(ids: [Int!]): Void
  markNotificationsAsRead: Void

  """
  Creates a buy now pay later order. Buy now pay later orders are orders which use a loan offer principal to buy and NFT and start a loan making the borrower the creator of the order. This method could return a SignatureRequest in __typename in which case you have to use this method again with the same input but you have to sign the 'typedData' response attribute and store it in the 'key' response attribute. You will have to do this process two times since multiple signatures are required. You should receive an BuyNowPayLaterOrder if everything went well. Refer to gondi-js examples for more details on how to sign it and pay the order.
  """
  publishBuyNowPayLaterOrder(orderInput: BNPLOrderInput!): BuyNowPayLaterOrderSignatureRequestExtraSeaportData!

  """
  Creates a collection trade order. This method could return a SignatureRequest in __typename in which case you have to use this method again with the same input but you have to sign the 'typedData' response attribute and store it in the 'key' response attribute. You should receive an CollectionOrder if everything went well. An order can only be a BID. Refer to gondi-js examples for more details.
  """
  publishOrderForCollection(orderInput: CollectionOrderInput!): CollectionOrderSignatureRequest!

  """
  Creates a single NFT trade order. This method could return a SignatureRequest in __typename in which case you have to use this method again with the same input but you have to sign the 'typedData' response attribute and store it in the 'key' response attribute. You should receive an SingleNFTOrder if everything went well. An order can be an ASK or a BID. Refer to gondi-js examples for more details.
  """
  publishOrderForNft(orderInput: SingleNFTOrderInput!): SingleNFTOrderSignatureRequest!

  """
  Creates a sell and repay loan order. Sell and repay orders are orders to sell an NFT and use that money to repay a loan leaving the rest for the borrower. This method could return a SignatureRequest in __typename in which case you have to use this method again with the same input but you have to sign the 'typedData' response attribute and store it in the 'key' response attribute. You will have to do this process two times since multiple signatures are required. You should receive an SellAndRepayOrder if everything went well. Refer to gondi-js examples for more details on how to sign it and pay the order.
  """
  publishSellAndRepayOrder(orderInput: NFTOrderInput!): SellAndRepayOrderSignatureRequest!

  """Removes a loan listing from a user."""
  removeListing(nftId: Int!): Listing!

  """Removes all the loan listings from a user. Can be filtered."""
  removeListingsOfNftsFromUser(excludeCollections: [String!] = null, onlyCollections: [String!] = null, searchTerm: String = null): Void

  """Removes a loan renegotiation request."""
  removeRenegotiationRequest(loanId: String!): RenegotiationRequest!

  """Removes a loan top-up request."""
  removeTopUpRequest(loanId: String!): TopUpRequest!

  """
  This is the second step of the renegotiation loan offer flow after generate_renegotiation_offer_to_be_signed. It saves the signed offer. Refer to gondi-js examples for more details.
  """
  saveRenegotiationSignedOffer(fallbackOfferInput: SingleNFTSignedOfferInput = null, signedRenegotiationInput: SignedRenegotiationOfferInput!): Renegotiation!

  """
  This is the second step of the collection loan offer flow after generate_collection_offer_to_be_signed. It saves the signed offer. Refer to gondi-js examples for more details.
  """
  saveSignedCollectionOffer(signedOfferInput: CollectionSignedOfferInput!): CollectionOffer!

  """
  This is the second step of the single NFT loan offer flow after generate_single_nft_offer_to_be_signed. It saves the signed offer. Refer to gondi-js examples for more details.
  """
  saveSignedSingleNftOffer(signedOfferInput: SingleNFTSignedOfferInput!): SingleNFTOffer!
  setReferral(referrerId: Int!): Void

  """Unhides a loan offer."""
  showOffer(contractAddress: Address!, offerId: String!): Offer!

  """Unhides a trade order."""
  showOrder(orderId: Int!): Order!

  """Unhides a loan renegotiation offer. """
  showRenegotiation(contractAddress: Address = "0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9", renegotiationId: String!): Renegotiation!
}

type NFT implements Node {
  """
  Active loan of the NFT, which can be of status INITIATED, SENT_TO_AUCTION or DEFAULTED.
  """
  activeLoan: Loan
  collection: Collection
  collectionId: Int
  createdDate: DateTime!
  description: String
  erc20Balances: [BigIntCurrencyAmount!]!
  id: String!
  image: Asset
  isFlagged: Boolean
  listed: Listing

  """Deprecated."""
  marketPlaceOfPrice: String @deprecated(reason: "Get it from nftPriceSample")
  maxNetPrincipalOffer(currencyAddress: Address!): Offer

  "\n        Naked NFT for the same token_id.\n        "
  nakedNft: NFT!
  name: String
  nftId: String!
  nftPriceSample(currencyAddresses: [Address!] = null, includeUserPrivateListings: Boolean = null): NFTPriceSample
  owner: Address

  """Deprecated."""
  price: BigInt @deprecated(reason: "Get it from nftPriceSample")

  """Deprecated."""
  priceCurrencyAddress: Address @deprecated(reason: "Get it from nftPriceSample")
  rarityRank: Int
  rarityScore: Float
  statistics: NftStatistics!
  tokenId: BigInt!
  traits: [Trait!]!
  url: String
  wrappedCount: [Int!]!

  "\n        All NFT IDs for the same token_id in all related collections (including itself,\n        naked and wrappers). Useful for finding analog NFTs across naked/wrapper\n        collections. Unrelated to the `wrap_nfts` and `wrapped_count` fields.\n        "
  wrappersAndNakedNftIds: [Int!]!

  "\n        All NFTs for the same token_id in all related collections (including itself,\n        naked and wrappers). Useful for finding analog NFTs across naked/wrapper\n        collections. Unrelated to the `wrap_nfts` and `wrapped_count` fields.\n        "
  wrappersAndNakedNfts: [NFT!]!
  wrapsNfts: [NFT!]
}

type NFTConnection {
  edges: [NFTEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NFTEdge {
  cursor: String!
  node: NFT!
}

input NFTOrderInput {
  amount: BigInt!
  contractAddress: Address!
  currencyAddress: Address!
  expirationTime: BigInt!
  fees: [OrderFee!] = null
  isAsk: Boolean!
  orderToFill: Int = null
  repaymentSignature: Signature = null
  replaceOrderId: Int = null
  signature: Signature = null
  startTime: BigInt!
  taker: Address = null
  tokenId: BigInt!
}

type NFTPriceSample implements Node {
  currencyAddress: Address!
  id: String!
  order: Order!
  orderId: Int!
  surveyedId: Int!
  taker: Address!
  timestamp: Int!
  value: BigInt!
}

type NewCollectionUnlistedOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type NewOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  offer: Offer!
  offerId: String!
  readOn: DateTime
  user: User!
}

type NewRenegotiationOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  renegotiation: Renegotiation!
  renegotiationId: String!
  user: User!
}

input NftLoansFilterInput {
  borrowers: [Address!] = null
  contracts: [Address!] = null
  excludeBorrowers: [Address!] = null
  excludeContracts: [Address!] = null
}

input NftOwnersFilterInput {
  excludeOwners: [Address!] = null
  owners: [Address!] = null
  withInLoan: Boolean = null
  withInStash: Boolean = null
  withInVault: Boolean = null
  withInWallet: Boolean = null
}

enum NftSortField {
  COLLECTION
  LAST_SALE_DATE
  LAST_SALE_PRICE
  NAME
  OFFERS_COUNT
  PRICE
  STATUS
}

input NftSortInput {
  field: NftSortField!
  order: Ordering!
  principalAddress: Address = null
}

type NftStatistics {
  highestBid(currencyAddresses: [Address!] = null): Order
  lastSale: Sale
  loansTotalVolume(currencyAddress: Address!): BigInt!

  """Deprecated field. Use number_of_offers_for_currencies instead."""
  numberOfOffers(currencyAddress: Address!): Float! @deprecated(reason: "Use number_of_offers_for_currencies instead.")
  numberOfOffersForCurrencies(currencyAddresses: [Address!]!): Int!
  topTraitFloorPrice: CurrencyAmount @deprecated(reason: "Trait floor price is not available")
}

input NftTermsFilter {
  price: BigIntInterval = null
}

input NftWithAsksConfigInput {
  currencyAddresses: [Address!] = null
  forTaker: Address = null
  marketplaces: [MarketPlaceType!] = null
  price: BigIntInterval = null
  withPrice: Boolean = null
}

enum NftsSortField {
  LAST_SALE_DATE
  LAST_SALE_PRICE
  LISTING_CREATED_DATE
  NAME
  OUTSTANDING_DEBT
  OUTSTANDING_LOAN_DUE_DATE
  PRICE
  TOKEN_ID
}

input NftsSortInput {
  currencyAddresses: [Address!] = null
  field: NftsSortField!
  forTaker: Address = null
  order: Ordering!
}

interface Node {
  id: String!
}

interface Notification implements Node {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type NotificationConnection {
  edges: [NotificationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NotificationEdge {
  cursor: String!
  node: Notification!
}

enum NotificationType {
  AUCTION_WON_NOTIFICATION
  LOAN_DEFAULTED_NOTIFICATION
  LOAN_DEFAULT_REMINDER_NOTIFICATION
  LOAN_REPAID_NOTIFICATION
  LOST_SOURCE_NOTIFICATION
  NEW_OFFER_NOTIFICATION
  NEW_RENEGOTIATION_OFFER_NOTIFICATION
  OFFER_ACCEPTED_NOTIFICATION
  OUTBID_NOTIFICATION
  SET_NFT_NOTIFICATION
}

interface Offer implements Event & Node {
  aprBps: BigInt!
  availablePrincipalAmount: BigInt!
  borrowerAddress: Address
  capacity: BigInt!
  collateralAddress: Address
  collectionId: Int
  consumedCapacity: BigInt!
  contractAddress: Address!
  createdDate: DateTime
  currency: Currency!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  hidden: Boolean
  id: String!
  lenderAddress: Address
  lenderAvailableBalance: BigInt
  maxPrincipal: BigInt!
  maxSeniorRepayment: BigInt!

  """Deprecated field: use maxSeniorRepayment instead."""
  maxTrancheFloor: BigInt! @deprecated(reason: "Use maxSeniorRepayment instead.")
  netPrincipal: BigInt!
  nftId: Int
  offerHash: Hash
  offerId: BigInt!
  principalAddress: Address!
  principalAmount: BigInt!
  repayment: BigInt!
  requiresLiquidation: Boolean
  signature: Signature
  signerAddress: Address
  status: String!
  timestamp: DateTime!
  validators: [OfferValidator!]!
}

type OfferAcceptedNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  offer: Offer!
  offerId: String!
  readOn: DateTime
  user: User!
}

type OfferConnection {
  edges: [OfferEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OfferEdge {
  cursor: String!
  node: Offer!
}

type OfferStatistics {
  consumedCapacity: BigInt!
}

enum OfferStatus {
  ACTIVE
  CANCELLED
  EXECUTED
  EXPIRED
  INACTIVE
  OUTPERFORMED
}

type OfferSteps implements Node {
  aprBpsStep: BigInt!
  collectionId: Int!
  id: String!
  origFeeBpsStep: BigInt!
  usdcStep: BigInt!
  wethStep: BigInt!
}

type OfferValidator implements Node {
  arguments: Hex!
  id: String!
  offerId: String!
  validator: Address!
}

input OfferValidatorInput {
  arguments: Hex!
  validator: Address!
}

enum OffersSortField {
  APR_BPS
  AVAILABLE_PRINCIPAL_AMOUNT
  CREATED_DATE
  DAILY_INTEREST
  DURATION
  EFFECTIVE_APR_BPS
  EXPIRATION
  FEE
  MAX_PRINCIPAL
  NET_INTEREST
  NET_PRINCIPAL
  PRINCIPAL_AMOUNT
  REPAYMENT
  STATUS
  TOTAL_INTEREST
}

input OffersSortInput {
  durationOfInterest: Int = null
  field: OffersSortField!
  order: Ordering!
  principalOfInterest: BigInt = null
}

interface Order implements Event & Node {
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

type OrderConnection {
  edges: [OrderEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrderEdge {
  cursor: String!
  node: Order!
}

input OrderFee {
  amount: BigInt!
  taker: Address!
}

input OrderForNft {
  collectionId: Int!
  nftId: Int!
}

enum OrderSide {
  ASK
  BID
}

enum OrderSortField {
  CREATED_DATE
  EXPIRATION
  FEE
  FEE_RATIO
  NET_AMOUNT
  PRICE
}

input OrderSortInput {
  field: OrderSortField!
  order: Ordering!
}

enum OrderStatusType {
  Active
  Cancelled
  Executed
  Expired
  Inactive
  Outperformed
}

input OrderTermsFilter {
  netAmount: BigIntInterval = null
}

enum OrderType {
  ASK
  BID
}

enum Ordering {
  ASC
  DESC
}

type OutbidNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  newBid: Bid!
  newBidId: Int!
  notificationType: String!
  readOn: DateTime
  user: User!
  userBid: Bid!
  userBidId: Int!
}

type OutstandingLoanStatistics {
  loansData(currencyAddress: Address): LoansData!
  outstandingLoanCount: Int!
  outstandingNftsCount: BigInt!
  outstandingPrincipal(currencyAddress: Address!): BigInt!
  totalOutstandingPrincipal: BigInt!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PointActivity implements Node {
  id: String!
  loanActivity: LoanActivity!
  points: BigInt!
  reason: String!
  timestamp: DateTime!
  userId: Int!
}

type PointActivityConnection {
  edges: [PointActivityEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PointActivityEdge {
  cursor: String!
  node: PointActivity!
}

type Pool implements Node {
  address: Address!
  asset: Currency!
  baseRateAllocator: PoolBaseRateAllocator!
  collectionFactors: [PoolCollectionFactors!]!
  currency: Currency!
  description: String!
  id: String!
  poolActivities: [PoolActivity!]!
  statistics: PoolStatistics!
}

interface PoolActivity implements Node {
  id: String!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  timestamp: DateTime!
  txHash: Hash!
}

type PoolActivityConnection {
  edges: [PoolActivityEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PoolActivityEdge {
  cursor: String!
  node: PoolActivity!
}

enum PoolActivityType {
  ERC4626_DEPOSIT
  ERC4626_WITHDRAW
  POOL_APR_FACTOR_SET
  POOL_APR_PREMIUM_SET
  POOL_BASE_INTEREST_ALLOCATOR_SET
  POOL_COLLECTION_FACTORS_SET
  POOL_REALLOCATED
  QUEUE_DEPLOYED
  WITHDRAWAL_POSITION_LOCKED
  WITHDRAWAL_POSITION_MINTED
  WITHDRAWN_FROM_QUEUE
}

type PoolAprFactorSet implements Node & PoolActivity {
  id: String!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  timestamp: DateTime!
  txHash: Hash!
}

type PoolAprPremiumSet implements Node & PoolActivity {
  aprPremium: BigInt!
  id: String!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  timestamp: DateTime!
  txHash: Hash!
}

type PoolBaseInterestAllocatorSet implements Node & PoolActivity {
  id: String!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  timestamp: DateTime!
  txHash: Hash!
}

type PoolBaseRateAllocator implements Node {
  address: Address!
  currency: Currency!
  description: String!
  id: String!
  stakeCurrency: Currency!
}

type PoolCollectionFactors implements Node {
  collection: Collection!
  collectionId: Int!
  duration: BigInt!
  id: String!
  offerId: String!
  pool: Pool!
  poolAddress: String!
  principalCurrentFactor: BigInt!
  principalHistoricalFactor: BigInt!
}

type PoolCollectionFactorsSet implements Node & PoolActivity {
  id: String!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  timestamp: DateTime!
  txHash: Hash!
}

type PoolConnection {
  edges: [PoolEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PoolEdge {
  cursor: String!
  node: Pool!
}

type PoolReallocated implements Node & PoolActivity {
  id: String!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  timestamp: DateTime!
  txHash: Hash!
}

type PoolStatistics {
  activeLoansCount: Int!
  activeOffersCount: Int!
  balanceAllocatedBaseRate: BigInt!
  liquid: BigInt!
  outstandingApr: Float!
  outstandingPrincipal: BigInt!
  realizedApr: Float!
  totalDeposits: BigInt!
  totalLoanVolume: BigInt!
}

"""Query for the lending module"""
type Query {
  """Get some general loan stats about the activities for a collection."""
  getCollectionActivitiesCount(collectionId: Int = null, currencyAddress: Address = null, fromTimestamp: Int!, slug: String = null): CollectionEventsCountByDayAndCurrency!

  """
  Get a collection by its slug. Slugs are unique identifiers for collections. 
  """
  getCollectionBySlug(slug: String!): Collection

  """Get some general loans stats from a collection."""
  getCollectionLoansData(collectionId: Int!, currencyAddress: Address): CollectionLoansData!
  getCollectionOfferSteps(collectionId: Int!): OfferSteps!
  getCollectionsByContractAddress(contractAddress: Address!): [Collection!]!
  getCurrency(address: Address!): Currency
  getListingById(listingId: Int!): Listing
  getLoanActivitiesStatisticsByMonth(activities: [LoanActivityType!]!, currencyAddress: Address!, lenders: [Address!]!): LoanActivitiesStatisticsByMonth!

  """
  Get a loan by the contract address and loan id used in the contract on-chain.Unless specified as in this case, loan id is the internal gondi id of the loan and not the id used inside the contract.Internal gondi id is unique between all loans.Note that contract loan id is only unique within a contract version and that Gondi has multiple versions of the MSL (MultiSourceLoan) contract.
  """
  getLoanById(address: String!, loanId: Int!): Loan
  getNftByContractAddressAndTokenId(contractAddress: Address!, tokenId: BigInt!): NFT
  getNftBySlugAndTokenId(slug: String!, tokenId: BigInt!): NFT
  getOrderCancelCalldata(orderId: Int!): Hex!
  getOrderSaleCalldata(nftId: Int = null, orderId: Int!, taker: Address = null): Hex!
  getOutstandingDebt(borrowers: [Address!]!, currencyAddress: Address!): BigInt!
  getOutstandingLoanStatistics: OutstandingLoanStatistics!
  getPointsFromReferrals: Int!
  getPoolByShareSymbol(symbol: String!): Pool
  getReferredWallets: Int!
  getSourcesStatistics(currencyAddress: Address!, lenders: [Address!]!, statuses: [LoanStatusType!]!): SourcesStatistics!
  getSourcesStatisticsByCollection(currencyAddress: Address!, lenders: [Address!]!, statuses: [LoanStatusType!]!): [SourceStatisticsFromCollection!]!
  getUserPointActivities(after: String, first: Int = null): PointActivityConnection!
  getUserPoints: Int!
  globalSearch(searchTerm: String!): [GlobalSearchResult!]!
  listAuctions(after: String, currencyAddress: Address = null, first: Int = null, sortBy: [AuctionSortInput!] = null, statuses: [AuctionStatus!] = null): AuctionConnection!
  listBids(after: String, auctionId: String = null, auctionStatuses: [AuctionStatus!] = null, bidders: [String!] = null, currencyAddress: Address = null, first: Int = null, onlyLatest: Boolean! = false, sortBy: [BidSortInput!] = null): BidConnection!
  listCollectionTraitTypes(after: String, collectionId: Int!, first: Int! = 40, valueType: TraitValueType = null): TraitTypeConnection!
  listCollectionTraitValues(after: String, collectionId: Int!, first: Int! = 40, key: [String!] = null, nftId: Int = null, onlyEnums: Boolean = null, searchTerm: String = null, sortBy: [TraitValueSortInput!] = null): TraitValueConnection!
  listCollections(after: String, collections: [Int!] = null, excludeCollections: [Int!] = null, excludeGondiUserVault: Boolean = false, first: Int = null, forWallets: ForWalletsInput = null, searchTerm: String = null, sortBy: [CollectionSortInput!] = null, standards: [TokenStandardType!] = null, withAsks: WithAsksInput = null, withListings: Boolean = false, withLoans: Boolean = false, wrappers: Boolean = null): CollectionConnection!

  """
  List NFT collections that have at least one listing. Listing an NFT is marking the NFT as available for taking loans and this can only be done by the owner of the NFT.
  """
  listCollectionsWithListings(after: String, collections: [Int!] = null, first: Int! = 10, searchTerm: String = null): CollectionConnection!

  """List NFT collections that have at least one loan."""
  listCollectionsWithLoans(after: String, collections: [Int!] = null, first: Int! = 10, searchTerm: String = null): CollectionConnection!
  listCurrencies(after: String, first: Int! = 20): CurrencyConnection!

  """
  List all activities. Includes loan activities, loan offers, loan renegotiations, trade orders, nft transfers.
  """
  listEvents(after: String, collections: [Int!] = null, currencyAddresses: [Address!] = null, eventTypes: [EventType!] = null, first: Int! = 10, nfts: [Int!] = null, toTimestamp: Int = null, traits: [Int!] = null, users: [Address!] = null): EventConnection!
  listListings(after: String, collectionIds: [Int!] = null, currencyAddress: Address = null, excludeSlugs: [String!] = null, first: Int = null, marketplaceNames: [MarketplaceEnum!] = null, searchTerm: String = null, slugs: [String!] = null, userFilter: UserFilter = null, withLoans: Boolean = false): ListingConnection!
  listListingsForSale(after: String, collectionId: Int = null, currencyAddress: Address = null, first: Int = null, forTaker: Address = null, hidden: Boolean = null, maker: Address = null, nftId: Int = null, sortBy: [OrderSortInput!] = null, statuses: [OrderStatusType!] = null): OrderConnection!

  """Deprecated."""
  listLoanActivities(after: String, collections: [Int!] = null, currencyAddress: Address = null, first: Int! = 10, fromTimestamp: Int = null, loanId: String = null, sortBy: [LoanActivitySortInput!] = null, types: [LoanActivityType!] = null): LoanActivityConnection! @deprecated(reason: "Use list_loan_events instead.")

  """
  List all events related to a loan. Useful to track the status changes of a loan.
  """
  listLoanEvents(after: String, collections: [Int!] = null, currencyAddress: Address = null, first: Int! = 10, fromTimestamp: Int = null, loanId: String = null, nfts: [Int!] = null, slugs: [String!] = null, sortBy: [LoanEventSortInput!] = null, types: [LoanEventType!] = null): LoanEventConnection!

  """Lists all loans from gondi."""
  listLoans(
    after: String
    borrowers: [String!] = null
    collections: [Int!] = null
    contractAddresses: [Address!] = null
    currencyAddress: Address = null
    excludeAddresses: [Address!] = null
    excludeSlugs: [String!] = null
    first: Int! = 10

    """
    Hide loans that are locked up for refinancing because of being close to expiration.Refinanced loans are locked at the end to avoid lenders to be pulled out at the last moment and lose a default profit.
    """
    hideEndLocked: Boolean = null

    """
    Hide loans that are locked up for refinancingbecause of recently initiated.Refinanced loans are locked at beggining to help lenders accrue some interest.
    """
    hideLocked: Boolean = null
    nfts: [Int!] = null
    orderByStatuses: Boolean = true

    """Filter by requests on the loan."""
    requestStatuses: [LoanRequestType!] = null
    searchTerm: String = null
    sluggedTokens: [SluggedTokenInput!] = null
    slugs: [String!] = null
    sortBy: [LoanSortInput!] = null
    statuses: [LoanStatusType!] = null
    terms: TermsFilter = null
  ): MultiSourceLoanConnection!
  listNftDelegations(after: String, contractAddress: Address = null, first: Int! = 20, nftId: Int!): DelegationConnection!
  listNftOffersAndRenegotiations(
    after: String
    collections: [Int!] = null

    """Offer only filter."""
    contractAddress: Address = null
    currencyAddress: Address = null
    first: Int = null
    hidden: Boolean = null

    """Renegotiation only filter."""
    isAddNewTranche: Boolean = null
    lenders: [String!] = null

    """Renegotiation only filter."""
    loanId: String = null

    """Offer only filter."""
    nfts: [Int!] = null
    onlyCollectionOffers: Boolean! = false
    onlyInvalid: Boolean! = false
    onlySingleNftOffers: Boolean! = true
    sortBy: OffersSortInput = null
    statuses: [OfferStatus!] = null
    terms: TermsFilter = null
  ): SingleNFTOfferCollectionOfferRenegotiationConnection!
  listNfts(
    after: String
    excludeSlugs: [String!] = null
    first: Int = null

    """
    Filter Nfts by the loans they are part of. You can provide contracts and exclude_contracts to control contract addresses. You can also provide borrowers and exclude_borrowers to control the borrowers of the loans.
    """
    loansFilter: NftLoansFilterInput = null
    nftIds: [Int!] = null

    """
    Filter by the owners of the NFTs. You can provide owners and exclude_owners to control the owners of the NFTs. with_in_wallet will include NFTS of the owners. with_in_loan will include NFTS on loan to the owners (as borrowers). with_in_stash will include NFTS in stashes of the owners. with_in_vault will include NFTS in vaults of the owners.
    """
    ownersFilter: NftOwnersFilterInput = null
    searchTerm: String = null
    slugs: [String!] = null
    sortBy: [NftsSortInput!] = null
    standards: [TokenStandardType!] = null
    traitRanges: [TraitRangeOptionsInput!] = null
    traits: [TraitKeyValueOptionsInput!] = null
    withAsksConfig: NftWithAsksConfigInput = null

    """
    If true, it will return the listed for loan NFTS only. If false, it won't return the listed NFTS
    """
    withListed: Boolean = null

    """
    If true, it will return the NFTS with wrapped nfts (vaults). If false, it won't return the NFTS with wrapped nfts (vaults)
    """
    withWraps: Boolean = null
  ): NFTConnection!

  """Deprecated field: use list_nfts instead."""
  listNftsFromCollections(after: String, collections: [Int!] = null, currencyAddresses: [Address!] = null, first: Int = null, marketplaces: [MarketPlaceType!] = null, onlyListed: Boolean = null, searchTerm: String = null, sortBy: [NftSortInput!] = null, terms: NftTermsFilter = null, traitRanges: [TraitRangeOptionsInput!] = null, traits: [TraitKeyValueOptionsInput!] = null): NFTConnection! @deprecated(reason: "Use list_nfts instead.")

  """Deprecated field: use list_nfts instead."""
  listNftsFromUser(after: String, collectionAddresses: [Address!] = null, first: Int = null, includeInStash: Boolean! = false, searchTerm: String = null, sortBy: [NftSortInput!] = null, standards: [TokenStandardType!] = null, withLoans: Boolean = false, withNoWraps: Boolean = false): NFTConnection! @deprecated(reason: "Use list_nfts instead.")
  listNotifications(after: String, first: Int = null, notificationTypes: [NotificationType!] = null, onlyRead: Boolean! = false, onlyUnread: Boolean! = false): NotificationConnection!
  listOffers(after: String, borrowerAddress: String = null, collections: [Int!] = null, contractAddress: Address = null, currencyAddress: Address = null, excludeLenders: [Address!] = null, first: Int = null, hidden: Boolean = null, lenders: [String!] = null, nfts: [Int!] = null, onlyCollectionOffers: Boolean = false, onlySingleNftOffers: Boolean = false, sluggedTokens: [SluggedTokenInput!] = null, slugs: [String!] = null, sortBy: [OffersSortInput!] = null, statuses: [OfferStatus!] = null, terms: TermsFilter = null, worseOffers: Boolean = true): OfferConnection!

  """
  This field is deprecated. Use list_orders_v2 instead. This field will be removed in the next major version.
  """
  listOrders(after: String, collectionId: Int = null, currencyAddresses: [Address!] = null, first: Int = null, hidden: Boolean = null, ids: [Int!] = null, maker: [Address!] = null, marketplaceIds: [String!] = null, marketplaces: [MarketPlaceType!] = null, nftId: Int = null, onlyInvalid: Boolean = null, orderType: OrderType = null, sortBy: [OrderSortInput!] = null, statuses: [OrderStatusType!] = null, taker: Address = null, terms: OrderTermsFilter = null): OrderConnection!
  listOrdersV2(after: String, collectionIds: [Int!] = null, currencyAddresses: [Address!] = null, excludeMaker: [Address!] = null, first: Int = null, hidden: Boolean = null, ids: [Int!] = null, maker: [Address!] = null, marketplaceIds: [String!] = null, marketplaces: [MarketPlaceType!] = null, nfts: [OrderForNft!] = null, onlyInvalid: Boolean = null, side: OrderSide = null, sortBy: [OrderSortInput!] = null, statuses: [OrderStatusType!] = null, taker: Address = null, terms: OrderTermsFilter = null, traitIds: [Int!] = null): OrderConnection!
  listPoolActivities(after: String, first: Int! = 20, ownerAddresses: [Address!] = null, poolAddresses: [Address!] = null, types: [PoolActivityType!] = null): PoolActivityConnection!
  listPools(addresses: [String!] = null, after: String, first: Int! = 10): PoolConnection!
  listRenegotiations(after: String, collections: [Int!] = null, first: Int = null, hidden: Boolean = null, isAddNewTranche: Boolean = null, loanId: String = null, sortBy: [OffersSortInput!] = null, statuses: [OfferStatus!] = null, terms: RefinanceTermsFilter = null): RenegotiationConnection!

  """
  List all sources. Sources are the lender/s of a loan. Lost sources on the other hand are the lender/s that have lost a loan because of renegotiation or refinance. When a renegotiation or refinance happens, the sources compromised turn into lost sources and new sources appear.
  """
  listSources(
    after: String
    collections: [Int!] = null
    contractAddresses: [Address!] = null
    currencyAddress: Address = null
    excludeAddresses: [Address!] = null
    excludeSlugs: [String!] = null
    first: Int! = 10
    hideEndLocked: Boolean = null
    hideLocked: Boolean = null

    """
    Include lost sources in the list. Lost sources are the lender/s that have lost a loan because of renegotiation or refinance. When a renegotiation or refinance happens, the sources compromised turn into lost sources and new sources appear.
    """
    includeLost: Boolean = null
    lenders: [String!] = null

    """
    Filter by the principal amount of the loan the source is part of. This is different than the principal amount of the source which only includes the amount lended by the source.
    """
    loanPrincipal: Interval = null
    slugs: [String!] = null
    sortBy: [SourceSortInput!] = null
    statuses: [LoanStatusType!] = null
    terms: TermsFilter = null
    withdrawalQueues: [Int!] = null
  ): SourceLostSourceConnection!
  listWithdrawalPositions(after: String, first: Int! = 10, owner: Address = null, poolAddresses: [Address!] = null): WithdrawalPositionConnection!
  listWithdrawalQueues(after: String, first: Int! = 10, poolAddresses: [Address!] = null): WithdrawalQueueConnection!
  me: User
}

type QueueDeployed implements Node & PoolActivity {
  id: String!
  index: Int!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  queueAddress: Address!
  timestamp: DateTime!
  txHash: Hash!
}

input RangeInput {
  max: Int!
  min: Int!
}

input RefinanceTermsFilter {
  aprBps: Interval = null
  duration: Interval = null
  fee: Interval = null
  maxPrincipal: Interval = null
  netPrincipal: Interval = null
  principal: Interval = null
  profitLeft: Interval = null
  remainingTime: Interval = null
}

"""
A renegotiation when the loan terms change and the borrower accepted. The difference with refinance is that renegotiation does not mean better terms for the borrower, because of that the borrower needs to accept the renegotiation. Also the renegotiation can be made by the same previous lender.Renegotiation can be top ups. A top up is when someone adds more principal to the loan.
"""
type Renegotiation implements Event & Node {
  aprBps: BigInt!
  availablePrincipalAmount: BigInt!
  createdDate: DateTime
  duration: BigInt!
  expirationTime: BigInt!
  fallbackOfferId: String
  feeAmount: BigInt!
  hidden: Boolean
  id: String!
  isAddNewTranche: Boolean!
  lenderAddress: Address
  loan: Loan!
  loanAddress: Address!
  loanId: BigInt!
  loanReferenceId: String!
  nft: NFT!
  offerHash: Hash
  principalAmount: BigInt!
  renegotiationId: BigInt!
  repayment: BigInt!
  requiresLiquidation: Boolean!
  signature: Signature
  signerAddress: Address
  status: String!
  strictImprovement: Boolean!
  timestamp: DateTime!
}

type RenegotiationConnection {
  edges: [RenegotiationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type RenegotiationEdge {
  cursor: String!
  node: Renegotiation!
}

input RenegotiationOfferInput {
  aprBps: BigInt!
  duration: BigInt!
  expirationTime: BigInt!
  feeAmount: BigInt!
  isAddNewTranche: Boolean = null
  lenderAddress: Address!
  loanId: String!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signerAddress: Address = null
  strictImprovement: Boolean = null
  targetPrincipal: [BigInt!] = null
  trancheIndex: [BigInt!] = null
}

type RenegotiationRequest implements Node {
  createdDate: DateTime!
  desiredAprBps: BigInt
  desiredDuration: BigInt
  desiredPrincipalAmount: BigInt
  expirationDate: DateTime!
  id: String!
  loanId: String!
}

type RenegotiationRequestedNotification implements Node & Notification {
  aprBps: BigInt
  createdOn: DateTime!
  duration: BigInt
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  principalAmount: BigInt
  readOn: DateTime
  user: User!
}

type Royalty implements Node {
  beneficiary: Address!
  id: String!
  percentage: Float!
  required: Boolean!
}

type Sale implements Activity & Event & Node {
  id: String!
  nft: NFT!
  order: Order!
  orderId: String!
  taker: Address!
  timestamp: DateTime!
  txHash: Hash!
}

type SellAndRepayOrder implements Event & Node & Order {
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  loan: MultiSourceLoan!
  loanId: String!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nft: NFT!
  nftId: Int!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  repaymentCalldata: Hex!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

union SellAndRepayOrderSignatureRequest = SellAndRepayOrder | SignatureRequest

scalar Signature

type SignatureRequest {
  key: String!
  typedData: TypedData!
}

input SignedRenegotiationOfferInput {
  aprBps: BigInt!
  duration: BigInt!
  expirationTime: BigInt!
  feeAmount: BigInt!
  isAddNewTranche: Boolean = null
  lenderAddress: Address!
  loanId: String!
  offerHash: Hash!
  principalAmount: BigInt!
  renegotiationId: BigInt!
  requiresLiquidation: Boolean = null
  signature: Signature!
  signerAddress: Address = null
  strictImprovement: Boolean = null
  targetPrincipal: [BigInt!] = null
  trancheIndex: [BigInt!] = null
}

type SingleNFTOffer implements Event & Node & Offer {
  aprBps: BigInt!
  availablePrincipalAmount: BigInt!
  borrowerAddress: Address
  capacity: BigInt!
  collateralAddress: Address
  collectionId: Int
  consumedCapacity: BigInt!
  contractAddress: Address!
  createdDate: DateTime
  currency: Currency!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  hidden: Boolean
  id: String!
  lenderAddress: Address
  lenderAvailableBalance: BigInt
  maxPrincipal: BigInt!
  maxSeniorRepayment: BigInt!

  """Deprecated field: use maxSeniorRepayment instead."""
  maxTrancheFloor: BigInt! @deprecated(reason: "Use maxSeniorRepayment instead.")
  netPrincipal: BigInt!
  nft: NFT!
  nftId: Int
  offerHash: Hash
  offerId: BigInt!
  principalAddress: Address!
  principalAmount: BigInt!
  repayment: BigInt!
  requiresLiquidation: Boolean
  signature: Signature
  signerAddress: Address
  statistics: OfferStatistics!
  status: String!
  timestamp: DateTime!
  validators: [OfferValidator!]!
}

union SingleNFTOfferCollectionOfferRenegotiation = CollectionOffer | Renegotiation | SingleNFTOffer

type SingleNFTOfferCollectionOfferRenegotiationConnection {
  edges: [SingleNFTOfferCollectionOfferRenegotiationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SingleNFTOfferCollectionOfferRenegotiationEdge {
  cursor: String!
  node: SingleNFTOfferCollectionOfferRenegotiation!
}

input SingleNFTOfferInput {
  aprBps: BigInt!
  borrowerAddress: Address!
  capacity: BigInt!
  contractAddress: Address!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  lenderAddress: Address!
  maxSeniorRepayment: BigInt = null
  maxTrancheFloor: BigInt = null
  nftId: Int!
  offerValidators: [OfferValidatorInput!]!
  principalAddress: Address!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signerAddress: Address = null
}

type SingleNFTOrder implements Event & Node & Order {
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nft: NFT!
  nftId: Int!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

input SingleNFTOrderInput {
  amount: BigInt!
  contractAddress: Address!
  currencyAddress: Address!
  expirationTime: BigInt!
  fees: [OrderFee!] = null
  isAsk: Boolean = null
  signature: Signature = null
  startTime: BigInt!
  taker: Address = null
  tokenId: BigInt!
}

union SingleNFTOrderSignatureRequest = SignatureRequest | SingleNFTOrder

input SingleNFTSignedOfferInput {
  aprBps: BigInt!
  borrowerAddress: Address!
  capacity: BigInt!
  contractAddress: Address!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  lenderAddress: Address!
  maxSeniorRepayment: BigInt = null
  maxTrancheFloor: BigInt = null
  nftId: Int!
  offerHash: Hash!
  offerId: BigInt!
  offerValidators: [OfferValidatorInput!]!
  principalAddress: Address!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signature: Signature!
  signerAddress: Address = null
}

input SluggedTokenInput {
  slug: String!
  tokenId: BigInt!
}

"""
This is the definition of a source. Sources are the lender/s of a loan. Take into account that the loan fields can change if renegotiation or refinance happens.If a renegotiation or refinance happens on a loan, the sources compromised turn into LostSource's.
"""
type Source implements Node {
  accruedInterest: BigInt!
  aprBps: BigInt!
  borrowerEaprBps: BigInt!
  earnedInterest: BigInt!
  effectiveDuration: BigInt!
  endDate: DateTime!
  expectedInterestLeft: BigInt!
  id: String!
  lenderAddress: String!
  lenderEaprBps: BigInt!
  loan: MultiSourceLoan!
  loanId: String!
  loanIndex: Int
  loanReferenceId: String!
  originationFee: BigInt!
  principalAmount: BigInt!
  profit: BigInt!
  refinanceNetAprBps: BigInt!
  repaidInterest: BigInt!
  seniorPrincipalAmount: BigInt
  startTime: DateTime!
}

type SourceHistory implements Node {
  accruedInterest: BigInt!
  aprBps: BigInt!
  id: String!
  lenderAddress: String!
  loanId: String!
  loanIndex: Int
  originationFee: BigInt!
  principalAmount: BigInt!
  seniorPrincipalAmount: BigInt
  startTime: DateTime!
}

union SourceLostSource = LostSource | Source

type SourceLostSourceConnection {
  edges: [SourceLostSourceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SourceLostSourceEdge {
  cursor: String!
  node: SourceLostSource!
}

enum SourceSortField {
  ACCRUED_INTEREST
  APR_BPS
  DUE_DATE
  DURATION
  EARNED_INTEREST
  END_DATE
  ORIGINATION_FEE
  PRINCIPAL_AMOUNT
  REFINANCE_NET_APR_BPS
  REPAID_INTEREST
  START_TIME
}

input SourceSortInput {
  field: SourceSortField!
  order: Ordering!
}

type SourceStatisticsFromCollection {
  collection: Collection!
  collectionId: String!
  stats: SourcesStatistics!
}

type SourcesStatistics {
  count: Int!
  earnedInterest: BigInt!
  expectedInterestLeft: BigInt!
  originationFee: BigInt!
  outstanding: BigInt!
  principal: BigInt!
  profit: BigInt!
  repaidInterest: BigInt!
  wavgAprBps: BigInt!
  wavgLenderEaprBps: BigInt!
}

type StatByCollection {
  collection: Collection!
  value: BigInt!
}

input TermsFilter {
  aprBps: Interval = null
  duration: Interval = null
  fee: Interval = null
  maxPrincipal: Interval = null
  netPrincipal: Interval = null
  principal: Interval = null
  profitLeft: Interval = null
  remainingTime: Interval = null
}

enum TokenStandardType {
  CRYPTOPUNKS
  ERC721
  ERC1155
  OLD_ERC721
}

type TopUpRequest implements Node {
  createdDate: DateTime!
  desiredAprBps: BigInt
  desiredTopUp: BigInt
  expirationDate: DateTime!
  id: String!
  loanId: String!
}

type TopUpRequestedNotification implements Node & Notification {
  aprBps: BigInt
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  topUp: BigInt
  user: User!
}

type Trait implements Node {
  collectionId: String!
  id: String!
  key: String!
  sampleAsset: Asset
  statistics: TraitStatistics! @deprecated(reason: "Trait statistics are not available")
  type: String!
  value: String!
}

input TraitKeyValueOptionsInput {
  key: String!
  values: [String!]!
}

type TraitOrder implements Event & Node & Order {
  collectionId: Int!
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  traitId: Int!
  updatedDate: DateTime!
}

input TraitRangeOptionsInput {
  key: String!
  range: RangeInput!
}

type TraitStatistics {
  floorPrice: CurrencyAmount
  highestBid: Order
  rarity: Int!
}

type TraitType implements Node {
  collectionId: Int!
  count: Int!
  id: String!
  key: String!
  max: Float
  min: Float
  valueType: String!
}

type TraitTypeConnection {
  edges: [TraitTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TraitTypeEdge {
  cursor: String!
  node: TraitType!
}

type TraitValue implements Node {
  collectionId: Int!
  id: String!
  key: String!
  rarity: Int!
  sampleAsset: Asset
  sampleAssetId: Int
  statistics: TraitStatistics!
  value: String!
}

type TraitValueConnection {
  edges: [TraitValueEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TraitValueEdge {
  cursor: String!
  node: TraitValue!
}

enum TraitValueSortField {
  ALPHABETICAL
  RARITY
}

input TraitValueSortInput {
  field: TraitValueSortField!
  order: Ordering!
}

enum TraitValueType {
  ENUM
  RANGE
}

type Transfer implements Activity & Event & Node {
  id: String!
  nft: NFT!
  receiver: Address!
  sender: Address!
  timestamp: DateTime!
  txHash: Hash!
}

type TypedData {
  domain: JSON!
  message: JSON!
  primaryType: String!
  types: JSON!
}

type UnderfundedOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  offer: Offer!
  offerId: String!
  readOn: DateTime
  user: User!
}

type User implements Node {
  about: String
  blockchain: String!
  createdDate: DateTime!
  id: String!
  linkedWallets: [LinkedWallets!]!
  mail: String
  mailValidationDate: DateTime
  originalProfilePicture: String
  profilePictureId: Int
  size64ProfilePicture: String
  size128ProfilePicture: String
  size256ProfilePicture: String
  size512ProfilePicture: String
  statistics: UserStatistics!
  twitterHandle: String
  updatedAt: DateTime
  usedProduct: Boolean!
  username: String
  walletAddress: Address!
}

input UserFilter {
  onlyOrExclude: Boolean!
  userId: Int!
}

type UserStatistics {
  """Deprecated field. Stat will be removed"""
  defaultedPrincipal(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Stat will be removed")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  interestEarnedByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  loanCount(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  loanCountByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  loanPrincipalByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")

  """Deprecated field. Use get_loan_activities_statistics_by_month instead."""
  originationCountAndPrincipalByMonth(currencyAddress: Address!, walletsAddresses: [Address!]!): [[BigInt!]!]! @deprecated(reason: "Use get_loan_activities_statistics_by_month instead.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  outstandingAccruedInterest(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  outstandingPrincipal(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  realizedProfits(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_loan_activities_statistics_by_month instead."""
  renegotiationCountAndPrincipalByMonth(currencyAddress: Address!, walletsAddresses: [Address!]!): [[BigInt!]!]! @deprecated(reason: "Use get_loan_activities_statistics_by_month instead.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  totalLentPrincipal(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  totalLoanCount(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  wavgOutstandingApr(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  wavgOutstandingAprByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  wavgRepaidApr(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  wavgRepaidAprByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")
}

"""Represents NULL values"""
scalar Void

input WithAsksInput {
  enabled: Boolean = false
  marketplaces: [MarketPlaceType!] = null
}

type WithdrawalPosition implements Node {
  available: BigInt!
  id: String!
  nft: NFT!
  nftId: Int!
  pending: BigInt!
  requested: BigInt!
  shares: BigInt!
  unlockTime: DateTime
  withdrawalQueue: WithdrawalQueue!
  withdrawalQueueId: Int!
  withdrawn: BigInt!
}

type WithdrawalPositionConnection {
  edges: [WithdrawalPositionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type WithdrawalPositionEdge {
  cursor: String!
  node: WithdrawalPosition!
}

type WithdrawalPositionLocked implements Node & PoolActivity {
  contract: Address!
  id: String!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  timestamp: DateTime!
  txHash: Hash!
  unlockTime: DateTime!
}

type WithdrawalPositionMinted implements Node & PoolActivity {
  contract: Address!
  id: String!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  receiver: Address!
  shares: BigInt!
  timestamp: DateTime!
  txHash: Hash!
}

type WithdrawalQueue implements Node {
  balance: BigInt!
  collection: Collection!
  collectionId: Int!
  id: String!
  index: Int!
  pending: BigInt!
  pool: Pool!
  poolAddress: Address!
  requested: BigInt!
  requesters: Int!
  startTime: DateTime!
  status: String!
  totalShares: BigInt!
  totalWithdrawn: BigInt!
}

type WithdrawalQueueConnection {
  edges: [WithdrawalQueueEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type WithdrawalQueueEdge {
  cursor: String!
  node: WithdrawalQueue!
}

type WithdrawnFromQueue implements Node & PoolActivity {
  available: BigInt!
  contract: Address!
  id: String!
  indexInBlock: Int!
  pool: Pool!
  poolAddress: Address!
  receiver: Address!
  timestamp: DateTime!
  txHash: Hash!
}