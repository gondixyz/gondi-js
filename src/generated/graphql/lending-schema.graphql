type ActiveOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  offer: Offer!
  offerId: String!
  readOn: DateTime
  user: User!
}

interface Activity implements Event & Node {
  id: String!
  timestamp: DateTime!
  txHash: Hash!
}

scalar Address

"""An artist or creator linked to NFTs or collections."""
type Artist implements Node {
  artistType: String!
  artworksCount: Int!
  bio: String
  collectionsCount: Int!
  ethMintAddresses: [String!]!
  id: String!
  image: Asset
  lastMint: NFT
  name: String!
  sales1d: Int!
  slug: String!
  socials: [String!]!
  totalVolume: Float!
  uniqueCollectors: Int!
  volume1d: Float!
  websites: [String!]!
}

input ArtistCollectionInput {
  collectionIds: [Int!]!
  source: ArtistCollectionSourceType
}

enum ArtistCollectionSourceType {
  COLLECTION_ARTISTS
  NFT_ARTISTS
}

type ArtistConnection {
  edges: [ArtistEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ArtistEdge {
  cursor: String!
  node: Artist!
}

enum ArtistSortField {
  ARTWORKS_COUNT
  COLLECTIONS_COUNT
  NAME
  SALES_1D
  TOTAL_VOLUME
  UNIQUE_COLLECTORS
  VOLUME_1D
}

input ArtistSortInput {
  field: ArtistSortField!
  order: Ordering!
}

enum ArtistType {
  ARTIST
  CREATOR
}

type Asset implements Node {
  accessTypeName: String!
  cacheUrl: String
  contentTypeMime: String!
  data: String!
  id: String!
}

type Auction implements Node {
  duration: BigInt
  endTime: DateTime
  highestBid: Bid
  id: String!
  loan: MultiSourceLoan!
  minBid: BigInt!
  originator: Address
  settler: Address
  startTime: DateTime
  status: String!
  triggerFee: BigInt
}

type AuctionBidConfirmationNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  bid: Bid!
  bidId: Int!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type AuctionConnection {
  edges: [AuctionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AuctionEdge {
  cursor: String!
  node: Auction!
}

type AuctionEndedNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

enum AuctionSortField {
  END_TIME
}

input AuctionSortInput {
  field: AuctionSortField!
  order: Ordering!
}

type AuctionStartedNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

enum AuctionStatus {
  ENDED
  LIVE
  PAST
  UPCOMING
}

type AuctionWonNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

input BNPLOrderInput {
  amounts: [BigInt!]!
  contractAddress: Address!
  emitSignature: Signature = null
  extraSeaportData: Hex = null
  loanDuration: BigInt!
  offerIds: [String!]!
  signature: Signature = null
  tokenId: BigInt!
}

type Bid implements Node {
  amount: BigInt!
  auction: Auction!
  auctionId: String!
  bidder: Address!
  id: String!
  indexInBlock: Int!
  timestamp: DateTime!
  txHash: Hash!
}

type BidConnection {
  edges: [BidEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type BidEdge {
  cursor: String!
  node: Bid!
}

type BidHistory {
  price: Float!
  timestamp: DateTime!
  value: Float!
}

enum BidSortField {
  BID
  HIGHEST_BID
}

input BidSortInput {
  field: BidSortField!
  order: Ordering!
}

scalar BigInt

type BigIntCurrencyAmount {
  amount: BigInt!
  currency: Currency!
}

input BigIntInterval {
  max: BigInt = null
  min: BigInt = null
}

enum BlockchainEnum {
  ETHEREUM
  HYPERLIQUID
}

type BuyNowPayLaterOrder implements Event & Node & Order {
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  emitCalldata: Hex!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nft: NFT!
  nftId: Int!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

union BuyNowPayLaterOrderSignatureRequestExtraSeaportData = BuyNowPayLaterOrder | ExtraSeaportData | SignatureRequest

type CancelAllOrdersCalldata {
  calldata: Hex!
  marketPlaceAddress: Address!
}

"""An NFT collection."""
type Collection implements Node {
  artists: [Artist!]!
  bannerImage: Asset
  collectionUrl: String
  contractData: ContractData!
  description: String
  discordUrl: String
  externalUrl: String
  hasTransferValidator: Boolean!
  id: String!
  image: Asset
  imageId: String
  maxNetPrincipalOffer(currencyAddress: Address!): CollectionOffer
  name: String
  nftsCount: Int

  """The first 10 NFTs of the collection, sorted ASC by token ID."""
  previewNfts: [NFT!]!
  royalties: [Royalty!]!
  slug: String!
  statistics: CollectionStatistics!
  supply: BigInt
  twitterUsername: String
  uniqueCollectors: Int!
  verified: Boolean!
  whitelistedSupply: Int!
  wrappedCollection: Collection
  wrappedCollectionId: Int
  wrapperCollections: [Collection!]!
}

type CollectionConnection {
  edges: [CollectionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CollectionEdge {
  cursor: String!
  node: Collection!
}

type CollectionEventsCountByDayAndCurrency {
  auctions: BigInt!
  buyouts: BigInt!
  defaults: BigInt!
  foreclosings: BigInt!
  originations: BigInt!
  refinancings: BigInt!
  renegotiations: BigInt!
  repayments: BigInt!
  topUps: BigInt!
}

type CollectionLoansData {
  maxAprBps: Float!
  maxPrincipalAmount: BigInt!
  maxRemainingTime: BigInt!
  minAprBps: Float!
  minPrincipalAmount: BigInt!
  minRemainingTime: BigInt!
}

type CollectionOffer implements Event & Node & Offer {
  aprBps: BigInt!
  availablePrincipalAmount: BigInt!
  borrowerAddress: Address
  capacity: BigInt!
  collateralAddress: Address
  collection: Collection!
  collectionId: Int
  consumedCapacity: BigInt!
  contractAddress: Address!
  createdDate: DateTime
  currency: Currency!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  hidden: Boolean
  id: String!
  lenderAddress: Address
  lenderAllowance: BigInt
  lenderAvailableBalance: BigInt
  maxPrincipal: BigInt!
  maxSeniorRepayment: BigInt!

  """Deprecated field: use maxSeniorRepayment instead."""
  maxTrancheFloor: BigInt! @deprecated(reason: "Use maxSeniorRepayment instead.")
  netPrincipal: BigInt!
  nftId: Int
  offerHash: Hash
  offerId: BigInt!
  principalAddress: Address!
  principalAmount: BigInt!
  repayment: BigInt!
  requiresLiquidation: Boolean
  signature: Signature
  signerAddress: Address
  statistics: CollectionOfferStatistics!
  status: String!
  timestamp: DateTime!
  validators: [OfferValidator!]!
}

input CollectionOfferInput {
  aprBps: BigInt!
  borrowerAddress: Address!
  capacity: BigInt!
  collectionId: Int!
  contractAddress: Address!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  lenderAddress: Address!
  maxSeniorRepayment: BigInt = null
  maxTrancheFloor: BigInt = null
  offerValidators: [OfferValidatorInput!]!
  principalAddress: Address!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signerAddress: Address = null
}

type CollectionOfferStatistics {
  acceptedLoans: Int!
  consumedCapacity: BigInt!
}

type CollectionOrder implements Event & Node & Order {
  collection: Collection!
  collectionId: Int!
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  executions: Int!
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  maxExecutions: Int!
  netAmount: BigInt!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

input CollectionOrderInput {
  amount: BigInt = null
  collectionId: Int!
  currencyAddress: Address!
  expirationTime: BigInt!
  fees: [OrderFee!] = null
  isAsk: Boolean = null
  maxExecutions: BigInt = null
  price: BigInt = null
  signature: Signature = null
  startTime: BigInt!
  taker: Address = null
}

union CollectionOrderSignatureRequest = CollectionOrder | SignatureRequest

input CollectionSignedOfferInput {
  aprBps: BigInt!
  borrowerAddress: Address!
  capacity: BigInt!
  collectionId: Int!
  contractAddress: Address!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  lenderAddress: Address!
  maxSeniorRepayment: BigInt = null
  maxTrancheFloor: BigInt = null
  offerHash: Hash!
  offerId: BigInt!
  offerValidators: [OfferValidatorInput!]!
  principalAddress: Address!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signature: Signature!
  signerAddress: Address = null
}

enum CollectionSortField {
  CONTRACT_CREATED_DATE
  FLOOR_PRICE
  FLOOR_PRICE_1D_CHANGE
  FLOOR_PRICE_7D_CHANGE
  FLOOR_PRICE_30D_CHANGE
  HIGHEST_BID
  LENDERS_OUTSTANDING_PRINCIPAL
  LISTING_COUNT
  LOAN_COUNT
  NUMBER_OF_SALES_1D
  NUMBER_OF_SALES_7D
  NUMBER_OF_SALES_30D
  OFFER_COUNT
  OUTSTANDING_PRINCIPAL
  OWNERS_TOTAL_VALUE
  SALE_LISTING_COUNT
  TOTAL_LOAN_VOLUME
  TOTAL_OUTSTANDING_PRINCIPAL
  TOTAL_VOLUME
  TOTAL_VOLUME_1D
  TOTAL_VOLUME_7D
  TOTAL_VOLUME_30D
  TRENDING_VOLUME
}

input CollectionSortInput {
  field: CollectionSortField!
  lenders: [Address!] = null
  marketplaces: [MarketPlaceType!] = null
  minNumberOfSales: BigInt = null
  order: Ordering!
  owners: [Address!] = null
  principalAddress: Address = null
}

type CollectionStatistics {
  bestOffer: CurrencyAmount @deprecated(reason: "Use highest_bid instead.")
  floorPrice: CurrencyAmount
  floorPrice1d: Float
  floorPrice7d: Float
  floorPrice30d: Float
  floorPriceHistory(fromDate: DateTime!, toDate: DateTime!): [FloatStatHistory!]!
  highestBid: Order
  maxAskPrice(currencyAddresses: [Address!] = null): BigIntCurrencyAmount
  minAskPrice(currencyAddresses: [Address!] = null): BigIntCurrencyAmount
  nftsCount: Float
  numberOfListings: Int!
  numberOfNftsOwned(walletAddresses: [Address!] = null): Int!

  """Deprecated field. Use number_of_offers_for_currencies instead."""
  numberOfOffers(currencyAddress: Address!): Float! @deprecated(reason: "Use number_of_offers_for_currencies instead.")
  numberOfOffersForCurrencies(currencyAddresses: [Address!]!): Int!
  numberOfPricedNfts(marketplaces: [MarketPlaceType!] = null): Int!
  numberOfSales1d: Int!
  numberOfSales7d: Int!
  numberOfSales30d: Int!
  outstandingLoanCount: Int!
  outstandingNftsCount: BigInt!
  outstandingPrincipal(currencyAddress: Address!): BigInt!
  percentageInOutstandingLoans: Float!
  repaymentRate: Float!
  topBidHistory(fromDate: DateTime!, toDate: DateTime!): [BidHistory!]!
  totalLoanVolume(currencyAddress: Address!): BigInt!
  totalLoanVolume1d(currencyAddress: Address!): BigInt!
  totalLoanVolume1m(currencyAddress: Address!): BigInt!
  totalLoanVolume1w(currencyAddress: Address!): BigInt!
  totalLoanVolume1y(currencyAddress: Address!): BigInt!
  totalLoanVolume2m(currencyAddress: Address!): BigInt!
  totalLoanVolume3m(currencyAddress: Address!): BigInt!
  totalLoanVolume4m(currencyAddress: Address!): BigInt!
  totalOutstandingPrincipal: BigInt!
  totalVolume: Float
  totalVolume1d: Float
  totalVolume1m: Float
  totalVolume1w: Float
  totalVolume1y: Float @deprecated(reason: "Field deprecated")
  totalVolume2m: Float @deprecated(reason: "Field deprecated")
  totalVolume3m: Float @deprecated(reason: "Field deprecated")
  totalVolume4m: Float @deprecated(reason: "Field deprecated")
}

type ContractData implements Node {
  blockchain: String!
  contractAddress: Address!
  createdDate: DateTime!
  creatorAddress: Address
  id: String!
  standard: String!
}

type Currency implements Node {
  address: Address!
  currentEthRate: Float
  currentUsdcPrice: Float
  decimals: Int!
  id: String!
  rateAtTime(timestamp: DateTime!): Float @deprecated(reason: "Use rate_at_times instead.")
  rateAtTimes(timestamps: [DateTime!]!): [Float]!
  symbol: String!
  usdcPriceAtTime(timestamp: DateTime!): Float @deprecated(reason: "Use usdc_price_at_times instead.")
  usdcPriceAtTimes(timestamps: [DateTime!]!): [Float]!
}

type CurrencyAmount {
  amount: Float!
  currency: Currency!
}

type CurrencyConnection {
  edges: [CurrencyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CurrencyEdge {
  cursor: String!
  node: Currency!
}

"""Date with time (isoformat)"""
scalar DateTime

type Deal implements Node {
  blockchain: String!
  counterOfferForId: Int
  counterOffered: Boolean!
  createdDate: DateTime!
  evmOrder: JSON
  expiration: DateTime!
  id: String!
  maker: Address!
  makerErc20s: [Address!]!
  makerErc20sAmounts: [BigInt!]!
  makerNfts: [NFT!]!
  makerNftsAmounts: [BigInt!]!
  marketPlaceAddress: Address!
  nonce: BigInt!
  signature: Signature
  status: String!
  taker: Address!
  takerErc20s: [Address!]!
  takerErc20sAmounts: [BigInt!]!
  takerNfts: [NFT!]!
  takerNftsAmounts: [BigInt!]!
  updatedDate: DateTime!
}

type DealConnection {
  edges: [DealEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DealEdge {
  cursor: String!
  node: Deal!
}

enum DealEventType {
  ACCEPTED
  CANCELLED
  EXPIRED
  INVALID
  RECEIVED
  RECEIVED_COUNTER_OFFER
  SENT
  SENT_COUNTER_OFFER
}

type DealExpirationReminderNotification implements Node & Notification {
  createdOn: DateTime!
  deal: Deal!
  dealId: Int!
  expiresInSeconds: Int!
  id: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

input DealInput {
  blockchain: BlockchainEnum!
  counterOfferForId: Int = null
  expiration: BigInt!
  makerErc20s: [Address!]!
  makerErc20sAmounts: [BigInt!]!
  makerNfts: [Int!]!
  makerNftsAmounts: [BigInt!]!
  signature: Signature
  startTime: BigInt!
  taker: Address!
  takerErc20s: [Address!]!
  takerErc20sAmounts: [BigInt!]!
  takerNfts: [Int!]!
  takerNftsAmounts: [BigInt!]!
}

type DealNotification implements Node & Notification {
  createdOn: DateTime!
  deal: Deal!
  dealId: Int!
  eventType: DealEventType!
  id: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

union DealSignatureRequest = Deal | SignatureRequest

enum DealSortField {
  CREATED_DATE
  EXPIRATION
  STATUS
}

input DealSortInput {
  field: DealSortField!
  order: Ordering!
}

type Delegation implements Node {
  contractAddress: String!
  delegateTo: Address!
  id: String!
  nft: NFT!
  timestamp: DateTime!
}

type DelegationConnection {
  edges: [DelegationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DelegationEdge {
  cursor: String!
  node: Delegation!
}

interface Event implements Node {
  id: String!
  timestamp: DateTime!
}

type EventConnection {
  edges: [EventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EventEdge {
  cursor: String!
  node: Event!
}

enum EventType {
  BUY_OFFER
  CLAIM
  COLLECTION_BUY_OFFER
  LOAN_AUCTIONED
  LOAN_BOUGHT_OUT
  LOAN_COLLECTION_OFFER
  LOAN_DEFAULTED
  LOAN_EXTENDED
  LOAN_FORECLOSED
  LOAN_INITIATED
  LOAN_LISTING
  LOAN_NFT_OFFER
  LOAN_PARTIAL_REFINANCED
  LOAN_PARTIAL_REFINANCED_TRANSFER
  LOAN_REFINANCED
  LOAN_REFINANCED_TRANSFER
  LOAN_RENEGOTIATED
  LOAN_RENEGOTIATED_PAYMENT
  LOAN_RENEGOTIATION_OFFER
  LOAN_REPAID
  LOAN_SENT_TO_AUCTION
  LOAN_TOPED_UP
  LOAN_TOP_UP_OFFER
  LOAN_TRANCHE_REFINANCED
  LOAN_TRANCHE_REFINANCED_TRANSFER
  SALE
  SALE_LISTING
  TRANSFER
}

enum ExclusiveListingType {
  FLOOR_PRICE
  IN_LOAN
  LOW_PRICE
}

type ExtraSeaportData {
  criteriaProof: [Hex!]
  extraData: Hex!
}

type FloatStatHistory {
  timestamp: DateTime!
  value: Float!
}

input ForWalletsInput {
  borrowersWallets: [Address!] = null
  lendersWallets: [Address!] = null
  ownersWallets: [Address!] = null
}

interface GlobalSearchResult {
  id: String!
}

type GlobalSearchResultAccount implements GlobalSearchResult {
  id: String!
  user: User!
}

type GlobalSearchResultCollection implements GlobalSearchResult {
  collection: Collection!
  id: String!
}

type GlobalSearchResultNFT implements GlobalSearchResult {
  id: String!
  nft: NFT!
}

scalar Hash

scalar Hex

"""64-bit integer as a JSON number."""
scalar Int64

input Interval {
  max: Float = null
  min: Float = null
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf).
"""
scalar JSON

type LinkedWallets implements Node {
  id: String!
  pending: Boolean!
  shouldAccept: Boolean!
  walletAddress: String!
}

type Listing implements Node {
  createdDate: DateTime!
  desiredDuration: Int
  desiredPrincipalAddress: Address
  expirationDate: DateTime!
  id: String!
  marketplaceName: MarketplaceEnum!
  nft: NFT!
  user: User!
}

type ListingConnection {
  edges: [ListingEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ListingEdge {
  cursor: String!
  node: Listing!
}

interface Loan implements Node {
  activities: [LoanActivity!]!
  address: Address!
  borrowerAddress: Address!
  contractStartTime: DateTime!
  currency: Currency!
  duration: BigInt!
  id: String!
  indexInBlock: Int!
  loanId: Int!

  """Deprecated field. Use offerIds to return loan offer ids instead."""
  offer: Offer! @deprecated(reason: "Use offerIds to return loan offer ids instead.")
  offerIds: [String!]!
  principalAddress: Address!
  protocolFee: BigInt!
  repaidActivity: LoanRepaid
  repaymentTime: DateTime
  startTime: DateTime!
  status: String!
  timestamp: DateTime!
  txHash: Hash!
}

type LoanActivitiesStatisticsByMonth {
  count: [Int!]!
  outstanding: [BigInt!]!
}

interface LoanActivity implements Event & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanActivityConnection {
  edges: [LoanActivityEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LoanActivityEdge {
  cursor: String!
  node: LoanActivity!
}

enum LoanActivitySortField {
  TIMESTAMP
}

input LoanActivitySortInput {
  field: LoanActivitySortField!
  order: Ordering!
}

enum LoanActivityType {
  LOAN_AUCTIONED
  LOAN_EXTENDED
  LOAN_FORECLOSED
  LOAN_INITIATED
  LOAN_REFINANCED
  LOAN_REFINANCED_FROM_OFFERS
  LOAN_REPAID
  LOAN_SENT_TO_AUCTION
}

type LoanAuctioned implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  loanPayments: [LoanPayment!]!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  totalAuctioned: BigInt!
  txHash: Hash!
  withBuyout: Boolean!
}

type LoanAuctionedNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type LoanDefaultReminderNotification implements Node & Notification {
  createdOn: DateTime!
  defaultsInHours: Int!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type LoanDefaulted implements Event & LoanEvent & Node {
  eventType: String!
  id: String!
  loan: Loan!
  loanId: String!
  timestamp: DateTime!
}

type LoanDefaultedNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

interface LoanEvent implements Event & Node {
  eventType: String!
  id: String!
  loan: Loan!
  loanId: String!
  timestamp: DateTime!
}

type LoanEventConnection {
  edges: [LoanEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LoanEventEdge {
  cursor: String!
  node: LoanEvent!
}

enum LoanEventSortField {
  PRINCIPAL_AMOUNT
  TIMESTAMP
}

input LoanEventSortInput {
  field: LoanEventSortField!
  order: Ordering!
}

enum LoanEventType {
  LOAN_AUCTIONED
  LOAN_BOUGHT_OUT
  LOAN_DEFAULTED
  LOAN_EXTENDED
  LOAN_FORECLOSED
  LOAN_INITIATED
  LOAN_REFINANCED
  LOAN_RENEGOTIATED
  LOAN_REPAID
  LOAN_SENT_TO_AUCTION
  LOAN_TOPED_UP
}

type LoanExtended implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanExtendedNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  newHistory: MultiSourceLoanHistory!
  newHistoryId: String!
  notificationType: String!
  previousHistory: MultiSourceLoanHistory!
  previousHistoryId: String!
  readOn: DateTime
  user: User!
}

type LoanForeclosed implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanInitiated implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

"""Loan listing created event"""
type LoanListingEvent implements Event & Node {
  createdDate: DateTime!
  desiredDuration: Int
  desiredPrincipalAddress: Address
  expirationDate: DateTime!
  id: String!
  marketplaceName: MarketplaceEnum!
  nft: NFT!
  timestamp: DateTime!
  user: User!
}

type LoanPayment implements Node {
  accruedInterest: BigInt!
  activityId: String!
  destination: Address!
  id: String!
  pendingInterest: BigInt!
  principalAddress: Address!
  principalAmount: BigInt!
  protocolFee: BigInt!
  source: Address!
}

type LoanRefinanced implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  addedNewTranche: Boolean!
  eventType: String!
  id: String!
  indexInBlock: Int!
  isRenegotiation: Boolean!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanRefinancedFromOffers implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  flashRefinance: Boolean!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

type LoanRefinancedNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  newHistory: MultiSourceLoanHistory!
  newHistoryId: String!
  notificationType: String!
  previousHistory: MultiSourceLoanHistory!
  previousHistoryId: String!
  readOn: DateTime
  user: User!
}

type LoanRepaid implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  totalInterest: BigInt!
  txHash: Hash!
}

type LoanRepaidNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

enum LoanRequestType {
  NFT_LISTED_FOR_SALE
  RENEGOTIATION_REQUEST
  TOP_UP_REQUEST
}

type LoanSentToAuction implements Event & LoanActivity & LoanEvent & Node {
  activityType: String!
  eventType: String!
  id: String!
  indexInBlock: Int!
  liquidatorAddress: String!
  loan: Loan!
  loanId: String!
  multiSourceLoanHistory: MultiSourceLoanHistory!
  nextActivity: LoanActivity
  prevActivity: LoanActivity
  timestamp: DateTime!
  txHash: Hash!
}

enum LoanSortField {
  APR_BPS
  DURATION
  EFFECTIVE_APR_BPS
  END_DATE
  EXPECTED_INTEREST
  EXPIRATION_DATE
  ORIGINATION_FEE
  PAID_INTEREST
  PRINCIPAL_AMOUNT
  RENEGOTIATION_REQUESTED
  START_TIME
  TOTAL_INTEREST
}

input LoanSortInput {
  field: LoanSortField!
  order: Ordering!
}

enum LoanStatusType {
  LOAN_AUCTIONED
  LOAN_AUCTIONED_WITH_BUYOUT
  LOAN_DEFAULTED
  LOAN_FORECLOSED
  LOAN_INITIATED
  LOAN_REPAID
  LOAN_SENT_TO_AUCTION
}

type LoansData {
  maxAprBps: Float!
  maxPrincipalAmount: BigInt!
  maxRemainingTime: BigInt!
  minAprBps: Float!
  minPrincipalAmount: BigInt!
  minRemainingTime: BigInt!
}

"""
This is the definition of a lost source. Lost sources are the lender/s that have lost a loan because of renegotiation or refinance. 
"""
type LostSource implements Node {
  accruedInterest: BigInt!
  activity: LoanActivity!
  activityId: String!
  aprBps: BigInt!
  duration: BigInt!
  earnedInterest: BigInt!
  endDate: DateTime!
  expectedInterestLeft: BigInt!
  id: String!
  lenderAddress: String!
  lenderEaprBps: BigInt!
  loan: MultiSourceLoan!
  netAccruedInterest: BigInt!
  netAprBps: BigInt!
  netEarnedInterest: BigInt!
  netExpectedInterestLeft: BigInt!
  netLenderEaprBps: BigInt!
  netOriginationFee: BigInt!
  netProfit: BigInt!
  netRepaidInterest: BigInt!
  originationFee: BigInt!
  principalAmount: BigInt!
  profit: BigInt!
  repaidInterest: BigInt!
  startTime: DateTime!
}

type LostSourceNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  lostSource: LostSource!
  lostSourceId: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

enum MarketPlaceType {
  BLUR
  CRYPTOPUNKS
  FOUNDATION
  LARVA_LABS
  LOOKS_RARE
  NATIVE
  NFTX
  NFT_STRATEGY
  OPEN_SEA
  X2Y2
}

enum MarketplaceEnum {
  GONDI
  NFTFI
}

"""
This is the definition of a loan. In sources you can find the tranches of the loan.Take into account that the loan fields can change if renegotiation or refinance happens.You can use listLoanEvents to get the history of the loan.
"""
type MultiSourceLoan implements Loan & Node {
  activities: [LoanActivity!]!
  address: Address!
  auction: Auction
  blendedAprBps: Float!
  borrowerAddress: Address!
  contractStartTime: DateTime!
  currency: Currency!
  duration: BigInt!
  durationFromRenegotiationOrStart: BigInt!
  endDate: DateTime!
  id: String!
  indexInBlock: Int!
  isEndLockedUp: Boolean!
  lastOriginationFee: BigInt!
  lastRenegotiationDate: DateTime
  loanId: Int!
  nft: NFT!

  """Deprecated field. Use offerIds to return loan offer ids instead."""
  offer: Offer! @deprecated(reason: "Use offerIds to return loan offer ids instead.")
  offerIds: [String!]!
  principalAddress: Address!
  principalAmount: BigInt!
  protocolFee: BigInt!
  renegotiationCount: Int!
  renegotiationRequest: RenegotiationRequest
  repaidActivity: LoanRepaid
  repayment: BigInt!
  repaymentTime: DateTime
  sources: [Source!]!
  startLockDueDate: DateTime
  startTime: DateTime!
  status: String!
  timestamp: DateTime!
  topUpRequest: TopUpRequest
  totalOriginationFee: BigInt!
  txHash: Hash!
}

type MultiSourceLoanConnection {
  edges: [MultiSourceLoanEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MultiSourceLoanEdge {
  cursor: String!
  node: MultiSourceLoan!
}

"""A snapshot in time of a loan."""
type MultiSourceLoanHistory implements Node {
  activity: LoanActivity!
  activityId: String!
  borrowerAddress: String!
  currency: Currency!
  duration: BigInt!
  durationFromRenegotiationOrStart: BigInt!
  id: String!
  lastRenegotiationDate: DateTime
  loanId: Int!
  nft: NFT!
  offerIds: [String!]!
  principalAddress: Address!
  principalAmount: BigInt!
  sources: [SourceHistory!]!
  startTime: DateTime!
}

type Mutation {
  """
  Lists all NFTs from a user to start receiving loan offers. Can be filtered to only match certain criteria.
  """
  addListingsOfNftsFromUser(desiredDuration: Int = null, desiredPrincipalAddress: Address = null, excludeCollections: [String!] = null, onlyCollections: [String!] = null, searchTerm: String = null): Void

  """Adds or updates a loan listing to start receiving loan offers."""
  addOrUpdateListing(desiredDuration: Int = null, desiredPrincipalAddress: Address = null, nftId: Int!): Listing!

  """
  Adds or updates a loan renegotiation request.A renegotiation request is only a suggestion for potential lenders to show your intentions and the terms you want.
  """
  addOrUpdateRenegotiationRequest(desiredAprBps: BigInt = null, desiredDuration: BigInt = null, desiredPrincipalAmount: BigInt = null, loanId: String!): RenegotiationRequest!

  """
  Adds or updates a loan top-up request.A top-up request is only a suggestion for potential lenders to show your intentions and the terms you want.
  """
  addOrUpdateTopUpRequest(desiredAprBps: BigInt = null, desiredTopUp: BigInt = null, loanId: String!): TopUpRequest!

  """Follow a collection for user feed."""
  followCollection(collectionId: Int!): Void

  """Follow multiple collections for user feed."""
  followCollections(collectionIds: [Int!]!): Void

  """
  This is the first step of the collection loan offer flow. This step populates some fields of the offer. You then have to sign the offer and save it using the method save_signed_collection_offer. Refer to gondi-js examples for more details.
  """
  generateCollectionOfferToBeSigned(offerInput: CollectionOfferInput!): CollectionOffer!

  """
  This is the first step of the renegotiation loan offer flow. This step populates some fields of the offer. You then have to sign the offer and save it using the method save_renegotiation_signed_offer. Refer to gondi-js examples for more details.
  """
  generateRenegotiationOfferToBeSigned(renegotiationInput: RenegotiationOfferInput!): Renegotiation!

  """
  This is the first step of the single NFT loan offer flow. This step populates some fields of the offer. You then have to sign the offer and save it using the method save_signed_single_nft_offer. Refer to gondi-js examples for more details.
  """
  generateSingleNftOfferToBeSigned(offerInput: SingleNFTOfferInput!): SingleNFTOffer!

  """Hides all loan offers from a user for a given contract address. """
  hideAllOffers(contractAddress: Address!, minOfferId: String!): [Offer!]!

  """Hides a loan offer."""
  hideOffer(contractAddress: Address!, offerId: String!): Offer!

  """Hides multiple loan offers."""
  hideOffers(contractAddress: Address!, offerIds: [String!]!): [Offer!]!

  """Hides a trade order."""
  hideOrder(orderIdInt64: Int64 = null): Order!

  """Hides a loan renegotiation offer. """
  hideRenegotiation(contractAddress: Address = "0xca5a494ca20483e21ec1e41fe1d9461da77595bd", renegotiationId: String!): Renegotiation!
  markNotificationIdsAsRead(ids: [Int!], walletAddresses: [Address!] = null): Void
  markNotificationsAsRead(walletAddresses: [Address!] = null): Void

  """
  Creates a buy now pay later order. Buy now pay later orders are orders which use a loan offer principal to buy and NFT and start a loan making the borrower the creator of the order. This method could return a SignatureRequest in __typename in which case you have to use this method again with the same input but you have to sign the 'typedData' response attribute and store it in the 'key' response attribute. You will have to do this process two times since multiple signatures are required. You should receive an BuyNowPayLaterOrder if everything went well. Refer to gondi-js examples for more details Platform fees are calculated automatically.on how to sign it and pay the order.
  """
  publishBuyNowPayLaterOrder(orderInput: BNPLOrderInput!): BuyNowPayLaterOrderSignatureRequestExtraSeaportData!

  """
  Creates a deal order. This method could return a SignatureRequest in __typename in which case you have to use this method again with the same input but you have to sign the 'typedData' response attribute and store it in the 'key' response attribute. You should receive a Deal if everything went well.
  """
  publishDealOrder(dealInput: DealInput!): DealSignatureRequest!

  """
  Creates a collection trade order. This method could return a SignatureRequest in __typename in which case you have to use this method again with the same input but you have to sign the 'typedData' response attribute and store it in the 'key' response attribute. You should receive an CollectionOrder if everything went well. An order can only be a BID. Platform fees are added to the fees array if not present.Refer to gondi-js examples for more details.
  """
  publishOrderForCollection(orderInput: CollectionOrderInput!): CollectionOrderSignatureRequest!

  """
  Creates a single NFT trade order. This method could return a SignatureRequest in __typename in which case you have to use this method again with the same input but you have to sign the 'typedData' response attribute and store it in the 'key' response attribute. You should receive an SingleNFTOrder if everything went well. An order can be an ASK or a BID. Platform fees are added to the fees array if not present.Refer to gondi-js examples for more details.
  """
  publishOrderForNft(orderInput: SingleNFTOrderInput!): SingleNFTOrderSignatureRequest!

  """
  Creates a sell and repay loan order. Sell and repay orders are orders to sell an NFT and use that money to repay a loan leaving the rest for the borrower. This method could return a SignatureRequest in __typename in which case you have to use this method again with the same input but you have to sign the 'typedData' response attribute and store it in the 'key' response attribute. You will have to do this process two times since multiple signatures are required. You should receive an SellAndRepayOrder if everything went well. Refer to gondi-js examples for more details Platform fees are added to the fees array if not present.on how to sign it and pay the order.
  """
  publishSellAndRepayOrder(orderInput: NFTOrderInput!): SellAndRepayOrderSignatureRequestExtraSeaportData!

  """Refreshes NFT metadata and image"""
  refreshNftMetadata(nftId: Int!): NFT!

  """Removes a loan listing from a user."""
  removeListing(nftId: Int!): Listing!

  """Removes all the loan listings from a user. Can be filtered."""
  removeListingsOfNftsFromUser(excludeCollections: [String!] = null, onlyCollections: [String!] = null, searchTerm: String = null): Void

  """Removes a loan renegotiation request."""
  removeRenegotiationRequest(loanId: String!): RenegotiationRequest!

  """Removes a loan top-up request."""
  removeTopUpRequest(loanId: String!): TopUpRequest!

  """
  This is the second step of the renegotiation loan offer flow after generate_renegotiation_offer_to_be_signed. It saves the signed offer. Refer to gondi-js examples for more details.
  """
  saveRenegotiationSignedOffer(fallbackOfferInput: SingleNFTSignedOfferInput = null, signedRenegotiationInput: SignedRenegotiationOfferInput!): Renegotiation!

  """
  This is the second step of the collection loan offer flow after generate_collection_offer_to_be_signed. It saves the signed offer. Refer to gondi-js examples for more details.
  """
  saveSignedCollectionOffer(signedOfferInput: CollectionSignedOfferInput!): CollectionOffer!

  """
  This is the second step of the single NFT loan offer flow after generate_single_nft_offer_to_be_signed. It saves the signed offer. Refer to gondi-js examples for more details.
  """
  saveSignedSingleNftOffer(signedOfferInput: SingleNFTSignedOfferInput!): SingleNFTOffer!
  setReferral(referrerId: Int!): Void

  """Unhides a loan offer."""
  showOffer(contractAddress: Address!, offerId: String!): Offer!

  """Unhides a trade order."""
  showOrder(orderIdInt64: Int64 = null): Order!

  """Unhides a loan renegotiation offer. """
  showRenegotiation(contractAddress: Address = "0xca5a494ca20483e21ec1e41fe1d9461da77595bd", renegotiationId: String!): Renegotiation!

  """Unfollow a collection for user feed."""
  unfollowCollection(collectionId: Int!): Void
}

type NFT implements Node {
  """
  Active loan of the NFT, which can be of status INITIATED, SENT_TO_AUCTION or DEFAULTED.
  """
  activeLoan: Loan
  animation: Asset
  artists: [Artist!]!
  collection: Collection
  collectionId: Int
  createdDate: DateTime!
  description: String
  erc20Balances: [BigIntCurrencyAmount!]!
  erc1155Balance(address: Address!): BigInt!
  id: String!
  image: Asset
  isExcluded: Boolean
  isFlagged: Boolean
  listed: Listing

  """Deprecated."""
  marketPlaceOfPrice: String @deprecated(reason: "Get it from nftPriceSample")
  maxNetPrincipalOffer(currencyAddress: Address = null): Offer

  "\n        Naked NFT for the same token_id.\n        "
  nakedNft: NFT!
  name: String
  nftId: String!
  nftPriceSample(currencyAddresses: [Address!] = null, includeUserPrivateListings: Boolean = null): NFTPriceSample
  owner: Address

  """Deprecated."""
  price: BigInt @deprecated(reason: "Get it from nftPriceSample")

  """Deprecated."""
  priceCurrencyAddress: Address @deprecated(reason: "Get it from nftPriceSample")
  rarityRank: Int
  rarityScore: Float
  statistics: NftStatistics!
  tokenId: BigInt!
  traits: [Trait!]!
  url: String
  wrappedCount: [Int!]!

  "\n        All NFT IDs for the same token_id in all related collections (including itself,\n        naked and wrappers). Useful for finding analog NFTs across naked/wrapper\n        collections. Unrelated to the `wrap_nfts` and `wrapped_count` fields.\n        "
  wrappersAndNakedNftIds: [Int!]!

  "\n        All NFTs for the same token_id in all related collections (including itself,\n        naked and wrappers). Useful for finding analog NFTs across naked/wrapper\n        collections. Unrelated to the `wrap_nfts` and `wrapped_count` fields.\n        "
  wrappersAndNakedNfts: [NFT!]!
  wrapsNfts: [NFT!]
}

type NFTConnection {
  edges: [NFTEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NFTEdge {
  cursor: String!
  node: NFT!
}

input NFTOrderInput {
  amount: BigInt = null
  contractAddress: Address!
  criteriaProof: [Hex!] = null
  currencyAddress: Address!
  expirationTime: BigInt!
  extraSeaportData: Hex = null
  fees: [OrderFee!] = null
  isAsk: Boolean!
  orderToFill: Int = null
  orderToFillInt64: Int64 = null
  price: BigInt = null
  repaymentSignature: Signature = null
  replaceOrderId: Int = null
  replaceOrderIdInt64: Int64 = null
  signature: Signature = null
  startTime: BigInt!
  taker: Address = null
  tokenId: BigInt!
}

type NFTPriceSample implements Node {
  bestOfferForBuyWithLoan: Offer
  currencyAddress: Address!
  id: String!
  order: Order!
  orderId: Int64!
  surveyedId: Int!
  taker: Address!
  timestamp: Int!
  value: BigInt!
}

type NewCollectionUnlistedOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type NewOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  offer: Offer!
  offerId: String!
  readOn: DateTime
  user: User!
}

type NewRenegotiationOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  renegotiation: Renegotiation!
  renegotiationId: String!
  user: User!
}

input NftLoansFilterInput {
  borrowers: [Address!] = null
  contracts: [Address!] = null
  excludeBorrowers: [Address!] = null
  excludeContracts: [Address!] = null
}

input NftOwnersFilterInput {
  excludeOwners: [Address!] = null
  owners: [Address!] = null
  withInLoan: Boolean = null
  withInStash: Boolean = null
  withInVault: Boolean = null
  withInWallet: Boolean = null
}

enum NftSortField {
  COLLECTION
  LAST_SALE_DATE
  LAST_SALE_PRICE
  NAME
  OFFERS_COUNT
  PRICE
  STATUS
}

input NftSortInput {
  field: NftSortField!
  order: Ordering!
  principalAddress: Address = null
}

type NftStatistics {
  highestBid(currencyAddresses: [Address!] = null): Order
  lastSale: Sale
  loansTotalVolume(currencyAddress: Address!): BigInt!

  """Deprecated field. Use number_of_offers_for_currencies instead."""
  numberOfOffers(currencyAddress: Address!): Float! @deprecated(reason: "Use number_of_offers_for_currencies instead.")
  numberOfOffersForCurrencies(currencyAddresses: [Address!]!): Int!
  topTraitFloorPrice: CurrencyAmount @deprecated(reason: "Trait floor price is not available")
}

type NftStrategyDeployment implements Node {
  collectionAddress: Address!
  contractAddress: Address!
  id: String!
}

type NftStrategyDeploymentConnection {
  edges: [NftStrategyDeploymentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NftStrategyDeploymentEdge {
  cursor: String!
  node: NftStrategyDeployment!
}

input NftTermsFilter {
  price: BigIntInterval = null
}

input NftWithAsksConfigInput {
  currencyAddresses: [Address!] = null
  forTaker: Address = null
  marketplaces: [MarketPlaceType!] = null
  price: BigIntInterval = null
  withPrice: Boolean = null
}

enum NftsSortField {
  HIGHEST_BID
  LAST_SALE_DATE
  LAST_SALE_PRICE
  LISTING_CREATED_DATE
  NAME
  OUTSTANDING_DEBT
  OUTSTANDING_LOAN_DUE_DATE
  PRICE
  STATUS
  TOKEN_ID
}

input NftsSortInput {
  currencyAddresses: [Address!] = null
  field: NftsSortField!
  forTaker: Address = null
  order: Ordering!
}

interface Node {
  id: String!
}

interface Notification implements Node {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  readOn: DateTime
  user: User!
}

type NotificationConnection {
  edges: [NotificationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NotificationEdge {
  cursor: String!
  node: Notification!
}

enum NotificationType {
  AUCTION_WON_NOTIFICATION
  DEAL_EXPIRATION_REMINDER_NOTIFICATION
  DEAL_NOTIFICATION
  LOAN_DEFAULTED_NOTIFICATION
  LOAN_DEFAULT_REMINDER_NOTIFICATION
  LOAN_REPAID_NOTIFICATION
  LOST_SOURCE_NOTIFICATION
  NEW_OFFER_NOTIFICATION
  NEW_RENEGOTIATION_OFFER_NOTIFICATION
  OFFER_ACCEPTED_NOTIFICATION
  OUTBID_NOTIFICATION
  SET_NFT_NOTIFICATION
}

interface Offer implements Event & Node {
  aprBps: BigInt!
  availablePrincipalAmount: BigInt!
  borrowerAddress: Address
  capacity: BigInt!
  collateralAddress: Address
  collectionId: Int
  consumedCapacity: BigInt!
  contractAddress: Address!
  createdDate: DateTime
  currency: Currency!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  hidden: Boolean
  id: String!
  lenderAddress: Address
  lenderAllowance: BigInt
  lenderAvailableBalance: BigInt
  maxPrincipal: BigInt!
  maxSeniorRepayment: BigInt!

  """Deprecated field: use maxSeniorRepayment instead."""
  maxTrancheFloor: BigInt! @deprecated(reason: "Use maxSeniorRepayment instead.")
  netPrincipal: BigInt!
  nftId: Int
  offerHash: Hash
  offerId: BigInt!
  principalAddress: Address!
  principalAmount: BigInt!
  repayment: BigInt!
  requiresLiquidation: Boolean
  signature: Signature
  signerAddress: Address
  status: String!
  timestamp: DateTime!
  validators: [OfferValidator!]!
}

type OfferAcceptedNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  offer: Offer!
  offerId: String!
  readOn: DateTime
  user: User!
}

type OfferConnection {
  edges: [OfferEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OfferEdge {
  cursor: String!
  node: Offer!
}

type OfferStatistics {
  consumedCapacity: BigInt!
}

enum OfferStatus {
  ACTIVE
  CANCELLED
  EXECUTED
  EXPIRED
  INACTIVE
  OUTPERFORMED
}

type OfferSteps implements Node {
  aprBpsStep: BigInt!
  collectionId: Int!
  id: String!
  origFeeBpsStep: BigInt!
  usdcStep: BigInt!
  wethStep: BigInt!
  whypeStep: BigInt!
}

type OfferValidator implements Node {
  arguments: Hex!
  id: String!
  offerId: String!
  validator: Address!
}

input OfferValidatorInput {
  arguments: Hex!
  validator: Address!
}

enum OffersSortField {
  APR_BPS
  AVAILABLE_PRINCIPAL_AMOUNT
  CREATED_DATE
  DAILY_INTEREST
  DURATION
  EFFECTIVE_APR_BPS
  EXPIRATION
  FEE
  MAX_PRINCIPAL
  NET_INTEREST
  NET_PRINCIPAL
  PRINCIPAL_AMOUNT
  REPAYMENT
  STATUS
  TOTAL_INTEREST
}

input OffersSortInput {
  durationOfInterest: Int = null
  field: OffersSortField!
  order: Ordering!
  principalOfInterest: BigInt = null
}

interface Order implements Event & Node {
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

type OrderConnection {
  edges: [OrderEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrderEdge {
  cursor: String!
  node: Order!
}

input OrderFee {
  amount: BigInt!
  taker: Address!
}

input OrderForNft {
  collectionId: Int!
  nftId: Int!
}

enum OrderKind {
  ALL
  PRIVATE
  PUBLIC
}

enum OrderModel {
  DEAL
  ORDER
}

enum OrderSide {
  ASK
  BID
}

enum OrderSortField {
  CREATED_DATE
  EXPIRATION
  FEE
  FEE_RATIO
  NET_AMOUNT
  PRICE
}

input OrderSortInput {
  field: OrderSortField!
  order: Ordering!
}

enum OrderStatusType {
  Active
  Cancelled
  Executed
  Expired
  Inactive
  Outperformed
}

input OrderTermsFilter {
  netAmount: BigIntInterval = null
}

enum OrderType {
  ASK
  BID
}

enum Ordering {
  ASC
  DESC
}

type OutbidNotification implements Node & Notification {
  auction: Auction!
  auctionId: String!
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  newBid: Bid!
  newBidId: Int!
  notificationType: String!
  readOn: DateTime
  user: User!
  userBid: Bid!
  userBidId: Int!
}

type OutstandingLoanStatistics {
  loansData(currencyAddress: Address): LoansData!
  outstandingLoanCount: Int!
  outstandingNftsCount: BigInt!
  outstandingPrincipal(currencyAddress: Address!): BigInt!
  totalOutstandingPrincipal: BigInt!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PlatformFee {
  beneficiary: Address!
  bps: BigInt!
}

enum PlatformFeeOperationType {
  BUY_NOW_PAY_LATER
  SALE
  SELL_AND_REPAY
}

type PointActivity implements Node {
  id: String!
  loanActivity: LoanActivity!
  points: BigInt!
  reason: String!
  timestamp: DateTime!
  userId: Int!
}

type PointActivityConnection {
  edges: [PointActivityEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PointActivityEdge {
  cursor: String!
  node: PointActivity!
}

"""Query for the lending module"""
type Query {
  """Get an artist by ID."""
  getArtist(artistId: Int!): Artist

  """Get an artist by slug."""
  getArtistBySlug(slug: String!): Artist

  """
  Get the borrowing power for a list of borrowers.Borrowing power is the sum of the best offer per NFT the borrower has.The best offer is the offer with the highest net principal.Returns the normalized sum in ETH equivalent (float).
  """
  getBorrowingPower(borrowers: [Address!]!): Float!
  getCancelAllNftOrdersCalldata(isAsk: Boolean = null, kind: OrderKind!, nftId: Int!, statuses: [OrderStatusType!] = null, walletAddress: Address!): [CancelAllOrdersCalldata!]!

  """Get some general loan stats about the activities for a collection."""
  getCollectionActivitiesCount(collectionId: Int = null, currencyAddress: Address = null, fromTimestamp: Int!, slug: String = null): CollectionEventsCountByDayAndCurrency!

  """
  Get a collection by its slug. Slugs are unique identifiers for collections. 
  """
  getCollectionBySlug(slug: String!): Collection

  """Get some general loans stats from a collection."""
  getCollectionLoansData(collectionId: Int!, currencyAddress: Address): CollectionLoansData!
  getCollectionOfferSteps(collectionId: Int!): OfferSteps!
  getCollectionsByContractAddress(contractAddress: Address!): [Collection!]!
  getCurrency(address: Address!): Currency
  getFeedId: String!
  getListingById(listingId: Int!): Listing
  getLoanActivitiesStatisticsByMonth(activities: [LoanActivityType!]!, currencyAddress: Address!, lenders: [Address!]!): LoanActivitiesStatisticsByMonth!

  """
  Get a loan by the contract address and loan id used in the contract on-chain.Unless specified as in this case, loan id is the internal gondi id of the loan and not the id used inside the contract.Internal gondi id is unique between all loans.Note that contract loan id is only unique within a contract version and that Gondi has multiple versions of the MSL (MultiSourceLoan) contract.
  """
  getLoanById(address: String!, loanId: Int!): Loan
  getNftByContractAddressAndTokenId(contractAddress: Address!, tokenId: BigInt!): NFT
  getNftBySlugAndTokenId(slug: String!, tokenId: BigInt!): NFT
  getOrderCancelCalldata(model: OrderModel = null, orderIdInt64: Int64 = null): Hex!
  getOrderSaleCalldata(model: OrderModel = null, nftId: Int = null, orderIdInt64: Int64 = null, taker: Address = null): Hex!
  getOutstandingDebt(borrowers: [Address!]!, currencyAddresses: [Address!] = null): BigInt!
  getOutstandingLoanStatistics: OutstandingLoanStatistics!
  getPointsFromReferrals: Int!
  getPurchaseBundlerFromOrder(orderId: Int64!): Address!
  getReferredWallets: Int!
  getSellAndRepayOrderSwapCalldata(expectedRate: Float!, loanId: String!, orderId: Int64!, slippage: Float!): Hex
  getSourcesStatistics(currencyAddress: Address!, lenders: [Address!]!, statuses: [LoanStatusType!]!): SourcesStatistics!
  getSourcesStatisticsByCollection(currencyAddress: Address!, lenders: [Address!]!, statuses: [LoanStatusType!]!): [SourceStatisticsFromCollection!]!
  getSwapRate(fromCurrency: Address!, toCurrency: Address!): Float!
  getUserPointActivities(after: String, first: Int = null): PointActivityConnection!
  getUserPoints: Int!
  globalSearch(searchTerm: String!): [GlobalSearchResult!]!

  """List artists/creators, optionally filtered by type."""
  listArtists(after: String, artistType: ArtistType = null, collection: ArtistCollectionInput = null, first: Int! = 10, sortBy: [ArtistSortInput!] = null): ArtistConnection!
  listAuctions(after: String, currencyAddress: Address = null, first: Int = null, sortBy: [AuctionSortInput!] = null, statuses: [AuctionStatus!] = null): AuctionConnection!
  listBids(after: String, auctionId: String = null, auctionStatuses: [AuctionStatus!] = null, bidders: [String!] = null, currencyAddresses: [Address!] = null, first: Int = null, onlyLatest: Boolean! = false, sortBy: [BidSortInput!] = null): BidConnection!

  """List collections for feed."""
  listCollectionFollows(after: String, feedId: String = null, first: Int! = 20): CollectionConnection!
  listCollectionTraitTypes(after: String, collectionIds: [Int!] = null, first: Int! = 40, valueType: TraitValueType = null): TraitTypeConnection!
  listCollectionTraitValues(after: String, collectionIds: [Int!] = null, first: Int! = 40, key: [String!] = null, nftId: Int = null, onlyEnums: Boolean = null, searchTerm: String = null, sortBy: [TraitValueSortInput!] = null): TraitValueConnection!
  listCollections(
    after: String

    """Filter by artist IDs to get linked collections."""
    artists: [Int!] = null
    collections: [Int!] = null
    excludeCollections: [Int!] = null
    excludeGondiUserVault: Boolean = false
    first: Int = null

    """Filter by floor price in ETH using an interval (min/max)."""
    floorPrice: Interval = null
    forWallets: ForWalletsInput = null
    searchTerm: String = null
    sortBy: [CollectionSortInput!] = null
    standards: [TokenStandardType!] = null
    withAsks: WithAsksInput = null
    withListings: Boolean = false
    withLoans: Boolean = false
    wrappers: Boolean = null
  ): CollectionConnection!

  """
  List NFT collections that have at least one listing. Listing an NFT is marking the NFT as available for taking loans and this can only be done by the owner of the NFT.
  """
  listCollectionsWithListings(after: String, collections: [Int!] = null, first: Int! = 10, searchTerm: String = null): CollectionConnection!

  """List NFT collections that have at least one loan."""
  listCollectionsWithLoans(after: String, collections: [Int!] = null, first: Int! = 10, searchTerm: String = null): CollectionConnection!
  listCurrencies(after: String, first: Int! = 20): CurrencyConnection!
  listDeals(after: String, first: Int = null, ids: [Int!] = null, sortBy: [DealSortInput!] = null, statuses: [OrderStatusType!] = null, walletAddresses: [Address!]!): DealConnection!

  """
  List all activities. Includes loan activities, loan offers, loan renegotiations, trade orders, nft transfers.
  """
  listEvents(after: String, collections: [Int!] = null, currencyAddresses: [Address!] = null, eventTypes: [EventType!] = null, first: Int! = 10, fromTimestamp: Int = null, nfts: [Int!] = null, toTimestamp: Int = null, topEvents: Boolean = null, traits: [Int!] = null, users: [Address!] = null): EventConnection!
  listListings(
    after: String
    blockchains: [BlockchainEnum!] = null
    collectionIds: [Int!] = null
    currencyAddresses: [Address!] = null
    excludeSlugs: [String!] = null
    first: Int = null

    """
    When filtering by collections, you can include vaults with items from the collections.
    """
    includeVaultsForCollections: VaultsFilter = null
    marketplaceNames: [MarketplaceEnum!] = null
    searchTerm: String = null
    slugs: [String!] = null
    userFilter: UserFilter = null
    withLoans: Boolean = false
  ): ListingConnection!
  listListingsForSale(after: String, collectionId: Int = null, currencyAddress: Address = null, first: Int = null, forTaker: Address = null, hidden: Boolean = null, maker: Address = null, nftId: Int = null, sortBy: [OrderSortInput!] = null, statuses: [OrderStatusType!] = null): OrderConnection!

  """Deprecated."""
  listLoanActivities(after: String, collections: [Int!] = null, currencyAddress: Address = null, first: Int! = 10, fromTimestamp: Int = null, loanId: String = null, sortBy: [LoanActivitySortInput!] = null, types: [LoanActivityType!] = null): LoanActivityConnection! @deprecated(reason: "Use list_loan_events instead.")

  """
  List all events related to a loan. Useful to track the status changes of a loan.
  """
  listLoanEvents(after: String, collections: [Int!] = null, currencyAddress: Address = null, first: Int! = 10, fromTimestamp: Int = null, loanId: String = null, nfts: [Int!] = null, slugs: [String!] = null, sortBy: [LoanEventSortInput!] = null, types: [LoanEventType!] = null): LoanEventConnection!

  """Lists all loans from gondi."""
  listLoans(
    after: String
    blockchains: [BlockchainEnum!] = null
    borrowers: [String!] = null
    collections: [Int!] = null
    contractAddresses: [Address!] = null
    currencyAddresses: [Address!] = null
    excludeAddresses: [Address!] = null
    excludeSlugs: [String!] = null
    first: Int! = 10

    """
    Hide loans that are locked up for refinancing because of being close to expiration.Refinanced loans are locked at the end to avoid lenders to be pulled out at the last moment and lose a default profit.
    """
    hideEndLocked: Boolean = null

    """
    Hide loans that are locked up for refinancingbecause of recently initiated.Refinanced loans are locked at beggining to help lenders accrue some interest.
    """
    hideLocked: Boolean = null

    """
    When filtering by collections, you can include vaults with items from the slugs.
    """
    includeVaultsForCollections: VaultsFilter = null
    nfts: [Int!] = null
    orderByStatuses: Boolean = true

    """Filter by requests on the loan."""
    requestStatuses: [LoanRequestType!] = null
    searchTerm: String = null
    sluggedTokens: [SluggedTokenInput!] = null
    slugs: [String!] = null
    sortBy: [LoanSortInput!] = null
    statuses: [LoanStatusType!] = null
    terms: TermsFilter = null
  ): MultiSourceLoanConnection!
  listNames(walletAddresses: [Address!]!): [String]!
  listNftDelegations(after: String, contractAddress: Address = null, first: Int! = 20, nftId: Int!): DelegationConnection!
  listNftOffersAndRenegotiations(
    after: String
    blockchains: [BlockchainEnum!] = null
    collections: [Int!] = null

    """Offer only filter."""
    contractAddresses: [Address!] = null
    currencyAddresses: [Address!] = null
    first: Int = null
    hidden: Boolean = null

    """Renegotiation only filter."""
    isAddNewTranche: Boolean = null
    lenders: [String!] = null

    """Renegotiation only filter."""
    loanId: String = null

    """Offer only filter."""
    nfts: [Int!] = null
    onlyCollectionOffers: Boolean! = false
    onlyInactiveOrHidden: Boolean! = false
    onlyInvalid: Boolean! = false
    onlySingleNftOffers: Boolean! = true
    sortBy: OffersSortInput = null
    statuses: [OfferStatus!] = null
    terms: TermsFilter = null
  ): SingleNFTOfferCollectionOfferRenegotiationConnection!
  listNftStrategyDeployments(after: String, first: Int = null): NftStrategyDeploymentConnection!
  listNfts(
    after: String
    artists: [Int!] = null
    blockchains: [BlockchainEnum!] = null
    burned: Boolean = null
    excludeSlugs: [String!] = null
    first: Int = null
    flagged: Boolean = null

    """
    When filtering by collections, you can include vaults with items from the slugs.
    """
    includeVaultsForCollections: VaultsFilter = null

    """
    Filter Nfts by the loans they are part of. You can provide contracts and exclude_contracts to control contract addresses. You can also provide borrowers and exclude_borrowers to control the borrowers of the loans.
    """
    loansFilter: NftLoansFilterInput = null
    nftIds: [Int!] = null

    """
    Filter by the owners of the NFTs. You can provide owners and exclude_owners to control the owners of the NFTs. with_in_wallet will include NFTS of the owners. with_in_loan will include NFTS on loan to the owners (as borrowers). with_in_stash will include NFTS in stashes of the owners. with_in_vault will include NFTS in vaults of the owners.
    """
    ownersFilter: NftOwnersFilterInput = null
    searchTerm: String = null
    slugs: [String!] = null
    sortBy: [NftsSortInput!] = null
    standards: [TokenStandardType!] = null
    traitRanges: [TraitRangeOptionsInput!] = null
    traits: [TraitKeyValueOptionsInput!] = null
    withAsksConfig: NftWithAsksConfigInput = null

    """
    If true, it will return the listed for loan NFTS only. If false, it won't return the listed NFTS
    """
    withListed: Boolean = null

    """
    If true, it will return the NFTS with wrapped nfts (vaults). If false, it won't return the NFTS with wrapped nfts (vaults)
    """
    withWraps: Boolean = null

    """If true, it won't return empty vaults"""
    withoutEmptyWraps: Boolean = null
  ): NFTConnection!

  """Deprecated field: use list_nfts instead."""
  listNftsFromCollections(after: String, collections: [Int!] = null, currencyAddresses: [Address!] = null, first: Int = null, marketplaces: [MarketPlaceType!] = null, onlyListed: Boolean = null, searchTerm: String = null, sortBy: [NftSortInput!] = null, terms: NftTermsFilter = null, traitRanges: [TraitRangeOptionsInput!] = null, traits: [TraitKeyValueOptionsInput!] = null): NFTConnection! @deprecated(reason: "Use list_nfts instead.")

  """Deprecated field: use list_nfts instead."""
  listNftsFromUser(after: String, collectionAddresses: [Address!] = null, first: Int = null, includeInStash: Boolean! = false, searchTerm: String = null, sortBy: [NftSortInput!] = null, standards: [TokenStandardType!] = null, withLoans: Boolean = false, withNoWraps: Boolean = false): NFTConnection! @deprecated(reason: "Use list_nfts instead.")
  listNotifications(after: String, first: Int = null, notificationTypes: [NotificationType!] = null, onlyRead: Boolean! = false, onlyUnread: Boolean! = false, walletAddresses: [Address!] = null): NotificationConnection!
  listOffers(after: String, blockchains: [BlockchainEnum!] = null, borrowerAddress: String = null, collections: [Int!] = null, contractAddresses: [Address!] = null, currencyAddress: Address = null, excludeLenders: [Address!] = null, first: Int = null, hidden: Boolean = null, lenders: [String!] = null, nfts: [Int!] = null, onlyCollectionOffers: Boolean = false, onlySingleNftOffers: Boolean = false, sluggedTokens: [SluggedTokenInput!] = null, slugs: [String!] = null, sortBy: [OffersSortInput!] = null, statuses: [OfferStatus!] = null, terms: TermsFilter = null, worseOffers: Boolean = true): OfferConnection!

  """
  This field is deprecated. Use list_orders_v2 instead. This field will be removed in the next major version.
  """
  listOrders(after: String, collectionId: Int = null, currencyAddresses: [Address!] = null, first: Int = null, hidden: Boolean = null, ids: [Int!] = null, maker: [Address!] = null, marketplaceIds: [String!] = null, marketplaces: [MarketPlaceType!] = null, nftId: Int = null, onlyInvalid: Boolean = null, orderType: OrderType = null, sortBy: [OrderSortInput!] = null, statuses: [OrderStatusType!] = null, taker: Address = null, terms: OrderTermsFilter = null): OrderConnection!
  listOrdersV2(after: String, collectionIds: [Int!] = null, currencyAddresses: [Address!] = null, excludeMaker: [Address!] = null, excludeTaker: [Address!] = null, exclusiveListings: Boolean = false, exclusiveListingsTypes: [ExclusiveListingType!] = null, first: Int = null, hidden: Boolean = null, ids: [Int!] = null, maker: [Address!] = null, marketplaceIds: [String!] = null, marketplaces: [MarketPlaceType!] = null, nfts: [OrderForNft!] = null, onlyInvalid: Boolean = null, side: OrderSide = null, sortBy: [OrderSortInput!] = null, statuses: [OrderStatusType!] = null, taker: Address = null, terms: OrderTermsFilter = null, traitIds: [Int!] = null): OrderConnection!
  listPlatformFees(blockchain: BlockchainEnum!, collectionId: Int!, marketplace: MarketPlaceType = null, operation: PlatformFeeOperationType!): [PlatformFee!]!
  listRenegotiations(after: String, blockchains: [BlockchainEnum!] = null, collections: [Int!] = null, first: Int = null, hidden: Boolean = null, isAddNewTranche: Boolean = null, loanId: String = null, sortBy: [OffersSortInput!] = null, statuses: [OfferStatus!] = null, terms: RefinanceTermsFilter = null): RenegotiationConnection!
  listSales(after: String, collections: [Int!] = null, currencyAddresses: [Address!] = null, first: Int! = 10, fromTimestamp: Int = null, nfts: [Int!] = null, sortBy: [SalesSortInput!] = null, toTimestamp: Int = null, traits: [Int!] = null, users: [Address!] = null): SaleConnection!

  """
  List all sources. Sources are the lender/s of a loan. Lost sources on the other hand are the lender/s that have lost a loan because of renegotiation or refinance. When a renegotiation or refinance happens, the sources compromised turn into lost sources and new sources appear.
  """
  listSources(
    after: String
    blockchains: [BlockchainEnum!] = null
    collections: [Int!] = null
    contractAddresses: [Address!] = null
    currencyAddresses: [Address!] = null
    excludeAddresses: [Address!] = null
    excludeSlugs: [String!] = null
    first: Int! = 10
    hideEndLocked: Boolean = null
    hideLocked: Boolean = null

    """
    Include lost sources in the list. Lost sources are the lender/s that have lost a loan because of renegotiation or refinance. When a renegotiation or refinance happens, the sources compromised turn into lost sources and new sources appear.
    """
    includeLost: Boolean = null
    lenders: [String!] = null

    """
    Filter by the principal amount of the loan the source is part of. This is different than the principal amount of the source which only includes the amount lended by the source.
    """
    loanPrincipal: Interval = null
    slugs: [String!] = null
    sortBy: [SourceSortInput!] = null
    statuses: [LoanStatusType!] = null
    terms: TermsFilter = null
    withdrawalQueues: [Int!] = null
  ): SourceLostSourceConnection!
  me: User
}

input RangeInput {
  max: Int!
  min: Int!
}

input RefinanceTermsFilter {
  aprBps: Interval = null
  duration: Interval = null
  ethProfitLeft: Interval = null
  fee: Interval = null
  maxPrincipal: Interval = null
  netPrincipal: Interval = null
  principal: Interval = null
  profitLeft: Interval = null
  remainingTime: Interval = null
}

"""
A renegotiation when the loan terms change and the borrower accepted. The difference with refinance is that renegotiation does not mean better terms for the borrower, because of that the borrower needs to accept the renegotiation. Also the renegotiation can be made by the same previous lender.Renegotiation can be top ups. A top up is when someone adds more principal to the loan.
"""
type Renegotiation implements Event & Node {
  aprBps: BigInt!
  availablePrincipalAmount: BigInt!
  createdDate: DateTime
  duration: BigInt!
  expirationTime: BigInt!
  fallbackOfferId: String
  feeAmount: BigInt!
  hidden: Boolean
  id: String!
  isAddNewTranche: Boolean!
  lenderAddress: Address
  loan: Loan!
  loanAddress: Address!
  loanId: BigInt!
  loanReferenceId: String!
  nft: NFT!
  offerHash: Hash
  principalAmount: BigInt!
  renegotiationId: BigInt!
  repayment: BigInt!
  requiresLiquidation: Boolean!
  signature: Signature
  signerAddress: Address
  status: String!
  strictImprovement: Boolean!
  timestamp: DateTime!
}

type RenegotiationConnection {
  edges: [RenegotiationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type RenegotiationEdge {
  cursor: String!
  node: Renegotiation!
}

input RenegotiationOfferInput {
  aprBps: BigInt!
  duration: BigInt!
  expirationTime: BigInt!
  feeAmount: BigInt!
  isAddNewTranche: Boolean = null
  lenderAddress: Address!
  loanId: String!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signerAddress: Address = null
  strictImprovement: Boolean = null
  targetPrincipal: [BigInt!] = null
  trancheIndex: [BigInt!] = null
}

type RenegotiationRequest implements Node {
  createdDate: DateTime!
  desiredAprBps: BigInt
  desiredDuration: BigInt
  desiredPrincipalAmount: BigInt
  expirationDate: DateTime!
  id: String!
  loanId: String!
}

type RenegotiationRequestedNotification implements Node & Notification {
  aprBps: BigInt
  createdOn: DateTime!
  duration: BigInt
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  principalAmount: BigInt
  readOn: DateTime
  user: User!
}

type Royalty implements Node {
  beneficiary: Address!
  id: String!
  percentage: Float!
  required: Boolean!
}

type Sale implements Activity & Event & Node {
  currencyAddress: Address!
  id: String!
  marketPlace: String!
  marketPlaceAddress: Address
  nft: NFT!
  order: Order
  orderId: String
  originatedFromAsk: Boolean
  price: BigInt!
  receiver: Address!
  sender: Address!
  taker: Address @deprecated(reason: "Deprecated field.")
  timestamp: DateTime!
  txHash: Hash!
}

type SaleConnection {
  edges: [SaleEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SaleEdge {
  cursor: String!
  node: Sale!
}

enum SalesSortField {
  PRICE
  TIMESTAMP
}

input SalesSortInput {
  field: SalesSortField!
  order: Ordering!
}

type SellAndRepayOrder implements Event & Node & Order {
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  loan: MultiSourceLoan!
  loanId: String!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nft: NFT!
  nftId: Int!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  repaymentCalldata: Hex!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

union SellAndRepayOrderSignatureRequestExtraSeaportData = ExtraSeaportData | SellAndRepayOrder | SignatureRequest

scalar Signature

type SignatureRequest {
  key: String!
  typedData: TypedData!
}

input SignedRenegotiationOfferInput {
  aprBps: BigInt!
  duration: BigInt!
  expirationTime: BigInt!
  feeAmount: BigInt!
  isAddNewTranche: Boolean = null
  lenderAddress: Address!
  loanId: String!
  offerHash: Hash!
  principalAmount: BigInt!
  renegotiationId: BigInt!
  requiresLiquidation: Boolean = null
  signature: Signature!
  signerAddress: Address = null
  strictImprovement: Boolean = null
  targetPrincipal: [BigInt!] = null
  trancheIndex: [BigInt!] = null
}

type SingleNFTOffer implements Event & Node & Offer {
  aprBps: BigInt!
  availablePrincipalAmount: BigInt!
  borrowerAddress: Address
  capacity: BigInt!
  collateralAddress: Address
  collectionId: Int
  consumedCapacity: BigInt!
  contractAddress: Address!
  createdDate: DateTime
  currency: Currency!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  hidden: Boolean
  id: String!
  lenderAddress: Address
  lenderAllowance: BigInt
  lenderAvailableBalance: BigInt
  maxPrincipal: BigInt!
  maxSeniorRepayment: BigInt!

  """Deprecated field: use maxSeniorRepayment instead."""
  maxTrancheFloor: BigInt! @deprecated(reason: "Use maxSeniorRepayment instead.")
  netPrincipal: BigInt!
  nft: NFT!
  nftId: Int
  offerHash: Hash
  offerId: BigInt!
  principalAddress: Address!
  principalAmount: BigInt!
  repayment: BigInt!
  requiresLiquidation: Boolean
  signature: Signature
  signerAddress: Address
  statistics: OfferStatistics!
  status: String!
  timestamp: DateTime!
  validators: [OfferValidator!]!
}

union SingleNFTOfferCollectionOfferRenegotiation = CollectionOffer | Renegotiation | SingleNFTOffer

type SingleNFTOfferCollectionOfferRenegotiationConnection {
  edges: [SingleNFTOfferCollectionOfferRenegotiationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SingleNFTOfferCollectionOfferRenegotiationEdge {
  cursor: String!
  node: SingleNFTOfferCollectionOfferRenegotiation!
}

input SingleNFTOfferInput {
  aprBps: BigInt!
  borrowerAddress: Address!
  capacity: BigInt!
  contractAddress: Address!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  lenderAddress: Address!
  maxSeniorRepayment: BigInt = null
  maxTrancheFloor: BigInt = null
  nftId: Int!
  offerValidators: [OfferValidatorInput!]!
  principalAddress: Address!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signerAddress: Address = null
}

type SingleNFTOrder implements Event & Node & Order {
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nft: NFT!
  nftId: Int!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  updatedDate: DateTime!
}

input SingleNFTOrderInput {
  amount: BigInt = null
  contractAddress: Address!
  currencyAddress: Address!
  expirationTime: BigInt!
  fees: [OrderFee!] = null
  isAsk: Boolean = null
  price: BigInt = null
  signature: Signature = null
  startTime: BigInt!
  taker: Address = null
  tokenId: BigInt!
}

union SingleNFTOrderSignatureRequest = SignatureRequest | SingleNFTOrder

input SingleNFTSignedOfferInput {
  aprBps: BigInt!
  borrowerAddress: Address!
  capacity: BigInt!
  contractAddress: Address!
  duration: BigInt!
  expirationTime: BigInt!
  fee: BigInt!
  lenderAddress: Address!
  maxSeniorRepayment: BigInt = null
  maxTrancheFloor: BigInt = null
  nftId: Int!
  offerHash: Hash!
  offerId: BigInt!
  offerValidators: [OfferValidatorInput!]!
  principalAddress: Address!
  principalAmount: BigInt!
  requiresLiquidation: Boolean = null
  signature: Signature!
  signerAddress: Address = null
}

input SluggedTokenInput {
  slug: String!
  tokenId: BigInt!
}

"""
This is the definition of a source. Sources are the lender/s of a loan. Take into account that the loan fields can change if renegotiation or refinance happens.If a renegotiation or refinance happens on a loan, the sources compromised turn into LostSource's.
"""
type Source implements Node {
  accruedInterest: BigInt!
  aprBps: BigInt!
  borrowerEaprBps: BigInt!
  earnedInterest: BigInt!
  effectiveDuration: BigInt!
  endDate: DateTime!
  expectedInterestLeft: BigInt!
  id: String!
  lenderAddress: String!
  lenderEaprBps: BigInt!
  loan: MultiSourceLoan!
  loanId: String!
  loanIndex: Int
  loanReferenceId: String!
  netAccruedInterest: BigInt!
  netAprBps: BigInt!
  netEarnedInterest: BigInt!
  netExpectedInterestLeft: BigInt!
  netLenderEaprBps: BigInt!
  netOriginationFee: BigInt!
  netProfit: BigInt!
  netRepaidInterest: BigInt!
  originationFee: BigInt!
  principalAmount: BigInt!
  profit: BigInt!
  refinanceNetAprBps: BigInt!
  repaidInterest: BigInt!
  seniorPrincipalAmount: BigInt
  startTime: DateTime!
}

type SourceHistory implements Node {
  accruedInterest: BigInt!
  aprBps: BigInt!
  id: String!
  lenderAddress: String!
  loanId: String!
  loanIndex: Int
  originationFee: BigInt!
  principalAmount: BigInt!
  seniorPrincipalAmount: BigInt
  startTime: DateTime!
}

union SourceLostSource = LostSource | Source

type SourceLostSourceConnection {
  edges: [SourceLostSourceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SourceLostSourceEdge {
  cursor: String!
  node: SourceLostSource!
}

enum SourceSortField {
  ACCRUED_INTEREST
  APR_BPS
  DUE_DATE
  DURATION
  EARNED_INTEREST
  END_DATE
  ORIGINATION_FEE
  PRINCIPAL_AMOUNT
  REFINANCE_NET_APR_BPS
  REPAID_INTEREST
  START_TIME
}

input SourceSortInput {
  field: SourceSortField!
  order: Ordering!
}

type SourceStatisticsFromCollection {
  collection: Collection!
  collectionId: String!
  stats: SourcesStatistics!
}

type SourcesStatistics {
  count: Int!
  earnedInterest: BigInt!
  expectedInterestLeft: BigInt!
  netEarnedInterest: BigInt!
  netExpectedInterestLeft: BigInt!
  netOriginationFee: BigInt!
  netProfit: BigInt!
  netRepaidInterest: BigInt!
  originationFee: BigInt!
  outstanding: BigInt!
  principal: BigInt!
  profit: BigInt!
  repaidInterest: BigInt!
  wavgAprBps: BigInt!
  wavgLenderEaprBps: BigInt!
  wavgNetAprBps: BigInt!
  wavgNetLenderEaprBps: BigInt!
}

type StatByCollection {
  collection: Collection!
  value: BigInt!
}

input TermsFilter {
  aprBps: Interval = null
  duration: Interval = null
  ethProfitLeft: Interval = null
  fee: Interval = null
  maxPrincipal: Interval = null
  netPrincipal: Interval = null
  principal: Interval = null
  profitLeft: Interval = null
  remainingTime: Interval = null
}

enum TokenStandardType {
  CRYPTOPUNKS
  ERC721
  ERC1155
  OLD_ERC721
}

type TopUpRequest implements Node {
  createdDate: DateTime!
  desiredAprBps: BigInt
  desiredTopUp: BigInt
  expirationDate: DateTime!
  id: String!
  loanId: String!
}

type TopUpRequestedNotification implements Node & Notification {
  aprBps: BigInt
  createdOn: DateTime!
  id: String!
  loan: MultiSourceLoan!
  loanId: String!
  notificationType: String!
  readOn: DateTime
  topUp: BigInt
  user: User!
}

type Trait implements Node {
  collectionId: String!
  id: String!
  key: String!
  sampleAsset: Asset
  statistics: TraitStatistics! @deprecated(reason: "Trait statistics are not available")
  type: String!
  value: String!
}

input TraitKeyValueOptionsInput {
  key: String!
  values: [String!]!
}

type TraitOrder implements Event & Node & Order {
  collectionId: Int!
  createdDate: DateTime!
  currency: Currency!
  currencyAddress: Address!
  evmOrder: JSON
  expiration: DateTime!
  fees: BigInt!
  hidden: Boolean!
  id: String!
  isAsk: Boolean!
  isPrivate: Boolean!
  maker: Address!
  marketPlace: String!
  marketPlaceAddress: Address!
  netAmount: BigInt!
  nonce: BigInt!
  orderType: String!
  originalId: Hash!
  price: BigInt!
  signature: Signature!
  startTime: DateTime!
  status: String!
  taker: Address!
  timestamp: DateTime!
  traitId: Int!
  updatedDate: DateTime!
}

input TraitRangeOptionsInput {
  key: String!
  range: RangeInput!
}

type TraitStatistics {
  floorPrice: CurrencyAmount
  highestBid: Order
  rarity: Int!
}

type TraitType implements Node {
  collectionId: Int!
  count: Int!
  id: String!
  key: String!
  max: Float
  min: Float
  valueType: String!
}

type TraitTypeConnection {
  edges: [TraitTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TraitTypeEdge {
  cursor: String!
  node: TraitType!
}

type TraitValue implements Node {
  collectionId: Int!
  id: String!
  key: String!
  rarity: Int!
  sampleAsset: Asset
  sampleAssetId: Int
  statistics: TraitStatistics!
  value: String!
}

type TraitValueConnection {
  edges: [TraitValueEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TraitValueEdge {
  cursor: String!
  node: TraitValue!
}

enum TraitValueSortField {
  ALPHABETICAL
  RARITY
}

input TraitValueSortInput {
  field: TraitValueSortField!
  order: Ordering!
}

enum TraitValueType {
  ENUM
  RANGE
}

type Transfer implements Activity & Event & Node {
  id: String!
  nft: NFT!
  receiver: Address!
  sender: Address!
  timestamp: DateTime!
  txHash: Hash!
}

type TypedData {
  domain: JSON!
  message: JSON!
  primaryType: String!
  types: JSON!
}

type UnderfundedOfferNotification implements Node & Notification {
  createdOn: DateTime!
  id: String!
  notificationType: String!
  offer: Offer!
  offerId: String!
  readOn: DateTime
  user: User!
}

type User implements Node {
  about: String
  blockchain: String! @deprecated(reason: "DEPRECATED")
  createdDate: DateTime!
  id: String!
  linkedWallets: [LinkedWallets!]!
  mail: String
  mailValidationDate: DateTime
  originalProfilePicture: String @deprecated(reason: "DEPRECATED")
  profilePictureId: Int
  size64ProfilePicture: String @deprecated(reason: "DEPRECATED")
  size128ProfilePicture: String @deprecated(reason: "DEPRECATED")
  size256ProfilePicture: String @deprecated(reason: "DEPRECATED")
  size512ProfilePicture: String @deprecated(reason: "DEPRECATED")
  statistics: UserStatistics!
  twitterHandle: String
  updatedAt: DateTime
  usedProduct: Boolean!
  username: String
  walletAddress: Address!
}

input UserFilter {
  onlyOrExclude: Boolean!
  userId: Int!
}

type UserStatistics {
  """Deprecated field. Stat will be removed"""
  defaultedPrincipal(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Stat will be removed")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  interestEarnedByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  loanCount(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  loanCountByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  loanPrincipalByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")

  """Deprecated field. Use get_loan_activities_statistics_by_month instead."""
  originationCountAndPrincipalByMonth(currencyAddress: Address!, walletsAddresses: [Address!]!): [[BigInt!]!]! @deprecated(reason: "Use get_loan_activities_statistics_by_month instead.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  outstandingAccruedInterest(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  outstandingPrincipal(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  realizedProfits(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_loan_activities_statistics_by_month instead."""
  renegotiationCountAndPrincipalByMonth(currencyAddress: Address!, walletsAddresses: [Address!]!): [[BigInt!]!]! @deprecated(reason: "Use get_loan_activities_statistics_by_month instead.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  totalLentPrincipal(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  totalLoanCount(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  wavgOutstandingApr(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  wavgOutstandingAprByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")

  """Deprecated field. Use get_sources_statistics to get source stats."""
  wavgRepaidApr(currencyAddress: Address!, walletsAddresses: [Address!]!): BigInt! @deprecated(reason: "Use get_sources_statistics to get source stats.")

  """Deprecated field. Use get_sources_statistics_by_collection instead."""
  wavgRepaidAprByCollection(currencyAddress: Address!, walletsAddresses: [Address!]!): [StatByCollection!]! @deprecated(reason: "Use get_sources_statistics_by_collection instead.")
}

enum VaultsFilter {
  EXCLUDE
  INCLUDE
  INCLUDE_SINGLE_COLLECTION
}

"""Represents NULL values"""
scalar Void

input WithAsksInput {
  enabled: Boolean = false
  marketplaces: [MarketPlaceType!] = null
}